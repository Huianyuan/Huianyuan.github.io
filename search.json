[{"title":"记一次nacos配置yml读取配置项","path":"/2023/08/11/2023.08.11记一次nacos配置yml读取配置项/","content":"记一次nacos配置yml读取配置项在nacos中，网关配置需要排除掉一些特定的接口地址的权限校验，项目接口较多的时候，若果不按照数组的形式配置，就会显得很冗长。 在项目中，因为是一期工程，接口地址较少，但是为了后期扩展方便。还是需要做一个配置更改。 先说下原本配置： 1234App： Auth： excludes1：/a/*,/b/*,/c/*# 直接配在一行，使用字符串数组接收值 下面是Spring中的使用 1234@Value($&#123;App.Auth.excludes&#125;)private String excludes;# 具体解析excludes的代码省略 在网上查找相关配置后，得到如下两种配置： 1234567891011App： Auth： excludes2：&gt; # 还是String /a/*, /b/*, /c/* excludes3: # 这里为List&lt;String&gt; - /a/* - /b/* - /c/* 注意，excludes2​虽然和excludes3 ​​有点像，但其excludes2​和excludes1​是同一种写法的不同风格，本质都是String​。只有excludes3​是数组形式，在Spring中使用时，得先创建一个类去读取配置： 123456@Data@Component@ConfigurationProperties(prefix=&quot;App.Auth&quot;)public class AppConfig&#123; private List&lt;String&gt; excludes3;&#125; 在网关过滤时，采用注入的方式使用这个变量： 12345@Autowiredprivate AppConfig appConfig;List&lt;String&gt; excludes3=appConfig.getExcludes3; ‍","tags":["Spring","nacos"],"categories":["Java"]},{"title":"MySQL自动备份","path":"/2023/08/09/2023.08.09MySQL数据库自动备份/","content":"因服务器断电，导致开发用服务奔溃，数据备份要做好。记录下自动备份脚本及命令。 1.创建脚本12mkdir -p /data/mysql/backup/backfiles # 新建备份目录vim /data/mysql/backup/mysql_backup.sh #编写脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/bin/bash以下配置信息请自己修改mysql_user=&quot;root&quot; #MySQL备份用户mysql_password=&quot;*******&quot; #MySQL备份用户的密码mysql_host=&quot;localhost&quot;mysql_port=&quot;3306&quot;mysql_charset=&quot;utf8&quot; #MySQL编码backup_db_arr=( &quot;qfwl360&quot; &quot;swooletp&quot; &quot;sys&quot; &quot;wxshop&quot; ) #要备份的数据库名称，多个用空格分开隔开 如(&quot;db1&quot; &quot;db2&quot; &quot;db3&quot;)backup_location=/data/mysql/backup/backfiles #备份数据存放位置，末尾请不要带&quot;/&quot;,此项可以保持默认，程序会自动创建文件夹expire_backup_delete=&quot;ON&quot; #是否开启过期备份删除 ON为开启 OFF为关闭expire_days=60 #过期时间天数 默认为三天，此项只有在expire_backup_delete开启时有效本行开始以下不需要修改backup_time=date +%Y%m%d%H%M #定义备份详细时间backup_Ymd=date +%Y-%m-%d #定义备份目录中的年月日时间backup_3ago=date -d &#x27;3 days ago&#x27; +%Y-%m-%d #3天之前的日期backup_dir=backuplocation/﻿backup_Ymd #备份文件夹全路径welcome_msg=&quot;Welcome to use MySQL backup tools!&quot; #欢迎语判断MYSQL是否启动,mysql没有启动则备份退出mysql_ps=ps -ef |grep mysql |wc -lmysql_listen=netstat -an |grep LISTEN |grep $mysql_port|wc -lif [ [mysqlps==0]−o[﻿mysql_listen == 0] ]; then echo &quot;ERROR:MySQL is not running! backup stop!&quot; exitelse echo $welcome_msgfi# 连接到mysql数据库，无法连接则备份退出mysql -hmysqlhost−P﻿mysql_port -umysqluser−p﻿mysql_password &lt;end $backup_dir/$dbname.sql.gz flag=echo $? if [ $flag == &quot;0&quot; ];then echo &quot;database dbnamesuccessbackupto﻿backup_dir/$dbname.sql.gz&quot; else echo &quot;database $dbname backup fail!&quot; fi done files=ls $backup_dir|awk &#x27;BEGIN&#123;ret=&quot;&quot;&#125;&#123;ret=ret&quot;,&quot;$0&#125;END&#123;print substr(ret,2)&#125;&#x27; mysql -hmysqlhost−P﻿mysql_port -umysqluser−p﻿mysql_password -sN -Dmysql_backup -e &quot;update mysql_backup_log set end_time=now(),note=&#x27;files′whereid=﻿logId&quot; else echo &quot;ERROR:No database to backup! backup stop&quot; exit fi # 如果开启了删除过期备份，则进行删除操作 if [ &quot;expirebackupdelete&quot;==&quot;ON&quot;−a&quot;﻿backup_location&quot; != &quot;&quot; ];then #find $backup_location/ -type d -o -type f -ctime +$expire_days -exec rm -rf &#123;&#125; \\; find $backup_location/ -type d -mtime +$expire_days | xargs rm -rf echo &quot;Expired backup data delete complete!&quot; fi echo &quot;All database backup success! Thank you!&quot; exitfi 2.修改权限递归地改变 mysql_backup.sh​ 文件的权限，以及可能还包括该文件所在的目录及其子目录的权限。​sudo chmod -R 777 mysql_backup.sh​ 3.设置每天凌晨5:00定时自动备份crontab -e​ 100 05 * * * /data/mysql/backup/mysql_backup.sh 4.创建备份记录库和记录表12345678910create database mysql_backup;CREATE TABLE mysql_backup_log ( id bigint(20) NOT NULL AUTO_INCREMENT, mysql_host varchar(30) NOT NULL, start_time datetime DEFAULT NULL, end_time datetime DEFAULT NULL, host varchar(30) DEFAULT NULL, note varchar(255) DEFAULT NULL, PRIMARY KEY (id)) ; 5.开启 定时任务systemctl status crond.service​ ‍","tags":["MySQL"],"categories":["数据库"]},{"title":"MySQL锁知识","path":"/2023/06/20/2023.06.20.058.MySQL锁知识/","content":"总分类如下： 粒度分类 全局锁 表锁 行锁 模式分类 乐观锁 悲观锁 属性分类 共享锁 排它锁 状态分类 意向共享 意向排他 算法分类 间隙锁 记录锁 临键锁 1.全局锁MySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。 读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。这在你需要在一段时间内保持数据一致性时很有用。 写锁（排他锁）：它阻正其他用户读取和更新数据。这在你需要修改一些大量的数据，并且不希望其他用户在这段时间内干扰时很有用。 MySQL全局锁的典型使用场景是，进行一些需要确保整个数据库一致性的操作，例如全库备份、全库导出等。 在MySql中，可以使用FLUSH TABLES WITH READ LOCK(FTWRL)​语句来添加全局读锁，这将阻止其他线程进行更新操作。使用UNLOCK TABLES​语句来释放锁定。 请注意，全局锁的开销非常大，因为它会阻止其他所有的数据修改操作，并且在高并发情况下可能导致大量的线程等待锁定。因此，你应该尽量避免在生产环境中使用全局锁，或者尽量减少全局锁的持有时间。 虽然全局锁有其应用场景，但是过度使用或不正确使用全局锁可能导致性能问题。因此，根据应用的特性和需求选择适合的锁策略是很重要的。对于大多数应用，优先使用更精细粒度的锁，如行锁和表锁，可以更有效地处理并发请求，同时避免全局锁的开销。 ‍ 2.表级锁加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 表锁有两种模式： 表共享读锁（Table Read Lock）：又称为表读锁，允许一个事务锁定的表进行读取操作，不允许其他事务对其进行写操作，但是可以进行读操作。读锁之间是不会互相阻塞的。 表独占写锁（TableWriteLock）：又称为表写锁，允许一个事务锁定的表进行读取和写入（更新）操作，但是其他任何事务都不能再对该表进行任何操作，必须等待表写锁结束。写锁会阻塞其他所有锁，包括读锁和写锁。 在MySQL中，对MyISAM表的读操作，会自动加上读锁，对MyISAM表的写操作，会自动加上写锁。 InnoDB引擎在必要情况下会使用表锁，但主要是使用行锁来实现多版本并发控制(MVCC），它能提供更好的并发性能和更少的锁冲突。 总的来说，表锁适用于读操作多、写操作少的应用，当并发争用不是特别激烈，以及记录级锁并发控制开销大于访问冲突开销的情况。在并发度高，或者写操作较多的情况下，表锁可能会成为瓶颈。 表级锁有哪些使用场景： 读密集型应用：如果你的应用主要进行读取操作，很少进行写入操作，那么使用表级锁可能是一个好选择。因为表级读锁不会阻塞其他的读锁，所以这种场景下表级锁能够提供很高的性能。 写操作不频繁的场景：表级锁对写操作的处理并不高效，因为一个写锁会阻塞所有其他的锁，无论它们是读锁还是写锁。但是，如果你的应用不需要频繁地进行写操作，或者可以容忍写操作的延迟，那么使用表级锁可能是可行的。 数据量不大的简单应用：如果数据库的数据量不大，那么即使在写操作中，由于锁定整张表，对性能的影响也不大。 全表更新或者删除；在某些情况下，可能需要对一张表进行全表的更新或者删除操作，例如，删除表中的所有记录，或者更新表中所有记录的某个字段的值。在这种情况下，使用表级锁是合适的。 MySQL哪些命令会发生表级锁： ALTER TABLE​：这个命令用于更改表的结构，如添加列、删除列、改变列的类型等。执行这个命令的时候，MySQL需要锁定整个表以防止在更改过程中有新的数据写入。 DROP TABLE​ 和 TRUNCATE TABLE​：这两个命令都会导致表级锁。DROP TABLE​命令会删除整个表，而TRUNCATE TABLE​命令会删除表中的所有数据。在执行这些命令的时候，MySQL需要锁定整个表以防止在删除过程中有新的数据写入。 LOCK TABLES​：这个命令可以显式地为一个或多个表加上读锁或写锁，LOCK TABLES​命令后面可以跟上一系列的表名和锁模式，用来指定需要锁定哪些表，以及使用什么样的锁模式。例如，LOCK TABLES t1 WRITE, t2 READ;​命令会给表t1加上写锁，给表t2加上读锁。 全表扫描或大范围扫描：对于MyISAM存储引擎，全表扫描或大范围扫描会触发表级锁。 FLUSH TABLES WITH READ LOCK(FTWRL）​：这个命令可以给所有表加上全局读锁，其他会话在此期间不能对数据进行修改。 请注意，InnoDB存储引擎主要使用行级锁，并在一些情况下使用表级锁，比如在执行某些ALTER TABLE​命令或者LOCK TABLES​命令时。MyISAM存储引擎只支持表级锁。 MySQL表锁风险点 性能下降：因为表锁会锁定整个表，所以在高并发的环境中，它可能导致大量的请求阻塞，从而降低性能。对于读取和写入混合密集的负载，表锁可能会成为一个性能瓶颈。 并发性能差：表锁的最大问题在于其并发性能。一旦一个线程对表获得了写锁，其他线程的任何读写操作都会被阻塞，直到写锁被释放。同样的，如果一个读锁被持有，那么其他的写操作将被阻塞。这就使得并发性能大大降低。 可能导致锁等待和超时：在高并发的环境中，由于表级锁的粒度较大，可能会有很多线程在等待锁，如果等待的时间过长，可能会导致锁超时，进一步影响应用的性能和可用性。 写操作影响大：如果一个长时间运行的写操作（比如大数据量的UPDATE或者INSERT语句）获取了写锁，那么会阻塞所有其他的读操作和写操作，直到这个写操作完成。 死锁的可能性：虽然表锁本身不会出现死锁，但在多表操作中，如果没有按照一定的顺序获得锁，可能会导致死锁。 为了避免这些问题，我们通常会选择InnoDB存储引擎，它主要使用行级锁，可以提供更好的并发性能，并且在一定程度上减少了锁争用的问题。而且，InnoDB还支持事务，可以保证数据的一致性和完整性。在实际应用中，我们应该根据具体的业务需求和系统负载，选择合适的存储引擎和锁策略。 3.行级锁什么是行锁行级锁是MySQL中的一种锁定机制，它可以对数据库表中的单独一行进行锁定。相比于表级锁和页锁，行级锁的粒度更小，因此在处理高并发事务时，能提供更好的并发性能和更少的锁冲突。然而，行级锁也需要更多的内存和CPU资源，因为需要对每一行都进行管理。在MySQL中，行级锁主要由InnoDB存储引擎提供。InnoDB支持两种类型的行级锁：共享锁(S锁）和排他锁（X锁）。 共享锁（S锁）：共享锁也称为读锁，它允许一个事务读取一行数据。当一行数据被共享锁锁定时，其他事务可以读取这行数据，但不能对其进行修改。 排他锁（X锁）：排他锁也称为写锁，它允许一个事务读取和修改一行数据。当一行数据被排他锁锁定时，其他事务不能读取也不能修改这行数据。 在实际使用中，InnoDB还提供了一种名为“间隙锁”（GapLock）的特性。间隙锁不仅锁定一个具体的行，还锁定它前后的“间隙”，即这一行之前的行和之后的行之间的空间。间隙锁可以防止其他事务插入新的行到已锁定行的前后，从而可以解决一些并发问题。 值得注意的是，行级锁只在事务中有效，也就是说，只有在一个事务开始（BEGIN）后并在事务提交（COMMIT）或回滚（ROLLBACK）之前，才能对数据行进行锁定。如果在非事务环境中执行SQL语句，那么InnoDB会在语句执行结束后立即释放所有的锁。 MySQL行锁有哪些使用场景MySQL中的行级锁（Row Level Locks）通常在以下几种场景中被使用： 高并发读写操作：在需要高并发读写操作的场景中，行级锁可以提高性能和并发性，因为它允许多个事务并发地操作不同的行。 单行操作：对于需要操作单行数据的SQL语句（例如基于主键或者唯一索引的UPDATE、DELETE和INSERT语句），行级锁可以提供较好的并发性和性能。 短期锁：在需要对数据行进行短时间锁定的情况下，行级锁可以防止长时间阻塞其他事务。 实现并发控制：在需要确保数据一致性和隔离性的事务中，行级锁是实现并发控制的重要机制。 复杂的事务处理：在需要对多行数据进行复杂处理的事务中，可以使用行级锁来锁定这些行，防止在事务处理过程中数据被其他事务修改。 使用行级锁需要注意，由于行级锁的锁定粒度较小，它可能会消耗更多的系统资源（例如内存和CPU），特别是在处理大量数据时。此外，使用行级锁也可能导致死锁，需要使用合适的策略来避免死锁，例如在事务中按照一定的顺序锁定行。 MySQL哪些命令会导致发生行锁在MySQL中，主要是InnoDB存储引擎提供了行级锁（Row Level Locking）。一般来说，以下这些类型的操作会导致InnoDB对数据行进行加锁： SELECT..FOR UPDATE​：这种查询会对选定的行添加一个排他锁（X锁），这意味着其他事务不能修改这些行，也不能对这些行添加共享锁。 SELECT..LOCK IN SHARE MODE​：这种查询会对选定的行添加一个共享锁（S锁），这意味着其他事务不能修改这些行，但可以对这些行添加共享锁。 INSERT​：插入操作会对新添加的行添加一个排他锁（X锁）。 UPDATE​：更新操作会对被更新的行添加一个排他锁（X锁）。 DELETE​：删除操作会对被删除的行添加一个排他锁（X锁）。 这些加锁操作都是在事务中进行的，即只有在事务开始(BEGIN）后并在事务提交(COMMIT）或回滚（ROLLBACK）之前，才会对数据行进行加锁。如果在非事务环境中执行上述SQL语句，那么InnoDB会在语句执行结束后立即释放所有的锁。 请注意，加锁的粒度和范围取决于WHERE子句​中用到的索引。如果WHERE子句​中用到了唯一索引​（例如主键索引），那么InnoDB只会锁定匹配的行。如果没有用到唯一索引，那么InnoDB可能会锁定更多的行，甚至是整个表，这就可能导致锁冲突和性能问题。 此外，InnoDB还支持间隙锁（Gap Locks）和临键锁（Next-Key Locks），这两种锁都可以在某些情况下提供更好的并发控制。 MySQL行锁有什么风险点？尽管行级锁（Row-LevelLocking）可以提供高并发性并减少锁冲突，但在使用过程中也可能遇到一些风险和问题，主要包括以下几点： 死锁：当两个或更多的事务相互等待对方释放资源时，就会发生死锁。例如，事务1锁定了行A并试图锁定行B，同时事务2锁定了行B并试图锁定行A，这就形成了死锁。MySQL会检测到死锁并终止其中一个事务，但这仍可能导致性能问题和事务失败。 锁升级：如果一个事务试图锁定的行过多，InnoDB可能会将锁从行级升级为表级，这就可能导致更多的锁冲突。 锁等待：如果一个事务已经锁定了某行，其他试图访问这行的事务就必须等待，这可能导致性能下降。如果有大量的事务在等待锁，就可能导致系统出现性能瓶颈。 资源消耗：行级锁需要更多的内存来存储锁信息，而且需要更多的CPU时间来处理锁请求和释放锁。如果数据库中的行数非常多，或者并发事务的数量非常多，这可能会导致显著的资源消耗。 难以调试和排查：由于行级锁的粒度较小，如果出现性能问题或锁冲突，可能需要复杂的调试和排查工作来找出问题的原因。 事务隔离级别：不同的事务隔离级别会影响锁的行为和性能，可能需要根据具体的应用场景来调整事务隔离级别。 为了避免上述问题，需要合理地设计数据库表和索引，合理地编写SQL语句，合理地管理事务，以及合理地设置事务隔离级别。 4.乐观锁什么是乐观锁乐观锁（Optimistic Locking）是一种在数据库操作中用于处理并发问题的技术。它的基本思想是假设在多个事务同时访问同一条数据时，冲突发生的概率较低，因此在操作数据时不会立即进行锁定，而是在提交数据更改时检查是否有其他事务修改了这条数据。如果没有，就提交更改，否则就回滚事务。 在MySQL中，乐观锁并没有内置的实现，但是可以通过一些编程技巧来实现。一种常见的实现方式是使用版本号（或时间戳）字段。每当一条记录被修改时，就增加版本号(或更新时间戳）。在更新记录时，先检查版本号(或时间戳）是否和读取记录时的版本号(或时间戳）一致，如果一致则执行更新并增加版本号（或更新时间戳），否则就拒绝更新。这样就可以保证只有当记录没有被其他事务修改时，当前事务的更改才会被提交。 乐观锁的优点在于，由于大部分时间都不需要锁定，所以在冲突较少的情况下可以获得较高的并发性能。然而，如果冲突较多，那么乐观锁可能会导致大量的事务回滚，从而影响性能。因此，选择使用乐观锁还是其他锁定技术，需要根据实际的并发情况和性能需求来决定。 乐观锁有哪些使用场景？乐观锁（Optimistic Locking）是一种对并发控制的策略，适用于以下的应用场景： 低冲突环境：在多数情况下，数据并发修改的冲突较低，即同一时间内，同一条数据不会被多个事务同时修改。 读多写少的场景：在读操作远多于写操作的情况下，乐观锁可以避免由于频繁的读操作导致的不必要的锁定开销。 短事务操作：如果数据库的事务都是简短并且快速完成的，那么使用乐观锁可以减少因为等待锁而导致的时间消耗。 分布式系统：在分布式系统中，由于网络延迟等原因，事务冲突的可能性较低，因此乐观锁是一个合适的选择。 互联网应用：对于互联网应用，如电子商务网站，用户浏览商品和下单等操作，多数情况下是读取操作，且并发修改同一条数据的几率较小，因此使用乐观锁可以提高系统性能。 需要注意的是，如果事务冲突的可能性较高，或者需要长时间锁定某个资源，那么使用乐观锁可能会导致大量的事务冲突和回滚，这种情况下，悲观锁或者其他并发控制技术可能会是更好的选择。 乐观锁的缺点 冲突检测：在高并发的环境中，乐观锁可能会导致大量的冲突。因为乐观锁只有在提交事务时才检查是否有冲突，如果多个事务同一时间操作同一行，那么只有一个事务能提交成功，其他的事务都需要回滚并重新尝试。 处理开销：在冲突发生时，需要进行回滚和重试，这可能会增加系统的开销。在一些场景中，这可能会导致性能下降。 版本管理：乐观锁通常通过版本号（或时间戳）来检测冲突。这就要求系统能够正确地管理这些版本号，否则可能会导致错误的冲突检测。 编程复杂性：使用乐观锁需要更复杂的编程，因为程序需要处理可能发生的冲突和重试。 总的来说，乐观锁是一种有效的并发控制策略，但在冲突较多的情况下，可能会带来更大的开销和编程复杂性。因此，是否选择使用乐观锁，需要根据应用的具体需求和场景来决定。 5.悲观锁什么是悲观锁？悲观锁（Pessimistic Locking）是一种并发控制的方法，基于一个假设：认为数据在并发处理过程中很可能会出现冲突。因此，为了保证数据的完整性和一致性，每次在读写数据时都会先加锁，这样可以避免其他事务进行并发的读写操作。 是否使用悲观锁需要根据应用的具体需求和场景来决定。在冲突较少，但需要保证数据完整性和一致性的情况下，可以考虑使用悲观锁。 MySQL悲观锁适用哪些场景？悲观锁的策略是假设数据在并发处理过程中会发生冲突，因此在进行任何读写操作前，都会预先加锁。这种策略在某些特定的应用场景下是比较有优势的，主要包括： 写操作较多的场景：如果一个系统中的写操作比读操作多，或者说写操作占主导，那么悲观锁可能是一个比较好的选择。因为在这种场景下，数据冲突的可能性相对较高，预先加锁可以确保数据的完整性和一致性。 并发冲突高的场景：在并发冲突较高的场景，使用悲观锁可以避免重复尝试操作，提高系统的整体效率。 业务需要强一致性的场景：在一些需要保证数据强一致性的业务场景下，例如银行转账等金融业务，通常会选择使用悲观锁，以确保在任何情况下数据的一致性和准确性。 但是值得注意的是，悲观锁也可能引入死锁等问题，也可能因为锁定过程中事务长时间等待而影响性能。因此，选择和使用悲观锁都需要根据具体业务场景和需求来进行。 MySQL如何使用悲观锁在MySQL中，悲观锁主要通过以下两种SQL语句实现： SELECTFOR UPDATE​：这个语句会在所选的行上设置排他锁​（Exclusive Lock）。在锁定期间，其他事务无法修改这些行，也无法在这些行上设置新的排他锁或共享锁。 SELECT..LOCK IN SHARE MODE​：这个语句会在所选的行上设置共享锁​（Shared Lock）。在锁定期间，其他事务可以读取这些行，但不能修改这些行，也不能在这些行上设雲置排他锁。 Q：悲观锁的缺点 性能开销：在悲观锁机制下，锁定资源的操作会影响到系统性能。因为每次对数据的读写都需要进行加锁和解锁的操作，这会增加系统的开销，特别是在高并发的环境下，锁的竟争更是会严重影响到系统性能。 并发度降低：由于悲观锁在操作数据前就会加锁，这就导致了在同一时间，只有一个事务能操作数据，其他事务只能等待，大大降低了系统的并发度。 死锁：悲观锁在并发事务中可能导致死锁的情况发生。当两个或者更多的事务互相等待对方释放锁时，就可能发生死锁。虽然数据库系统通常能够检测并解决死锁，但这会导致事务回滚，增加了系统的开销。 超时锁：如果一个事务长时间持有锁而不释放，可能导致其他等待锁的事务超时。这不仅可能导致等待的事务失败，还可能影响到整个系统的稳定性。 因此，虽然悲观锁能有效地防止数据冲突，但由于其在并发处理中的限制，以及可能引发的问题，如死锁、竞争锁和超时锁，我们需要根据具体的应用场景和需求，来权衡是否使用悲观锁。 6.意向共享锁和意向排它锁意向锁是表锁，为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。 作用：当有事务A有行锁时，MySQL会自动为该表添加意向锁，事务B如果想申请整个表的写锁，那么不需要遍历每一行判断是否存在行锁，而直接判断是否存在意向锁，增强性能。 为什么意向锁是表级锁呢？ 当我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）； 如果意向锁是行锁，则需要遍历每一行数据去确认； 如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。 意向锁怎么支持表锁和行锁并存？ 首先明确并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务A持有行锁、又有一个事务B持有表锁，因为表一旦被上了一个表级的写锁，肯定不能再上一个行级的锁。 如果事务A对某一行上锁，其他事务就不可能修改这一行。这与“事务B锁住整个表就能修改表中的任意一行”形成了冲突。所以，没有意向锁的时候，让行锁与表锁共存，就会带来很多问题。于是有了意向锁的出现，如前面所言，数据库不需要在检查每一行数据是否有锁，而是直接判断一次意向锁是否存在即可，能提升很多性能。 意向锁的兼容互斥性 意向共享锁(IS) 意向排他锁(IX) 共享锁(S） 兼容 互斥 排他锁(X) 互斥 互斥 7.临键锁什么是临键锁 Next-Key​可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临建锁可以解决幻读的问题。每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭​区间的数据。需要强调的一点是，InnoDB中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。 8.记录锁什么是记录锁 记录锁（Record Lock​）是MySQL数据库中InnoDB存储引擎的一种锁定机制，主要用于锁定和控制对单个行记录的访问。记录锁是在索引记录上设置的，对于表没有主键或唯一索引的表，InnoDB会生成一个隐藏的聚簇索引，并在这个隐藏索引上加锁。 在实际操作中，记录锁通常会在进行数据查询、更新或删除等操作时自动被数据库引擎应用。 例如，当执行以下查询时，MySQL会在Orders表的OrderID为1的行上设置记录锁： SELECT * FROM Orders WHERE OrderID=1 FOR UPDATE;​ 记录锁主要有两种类型：共享锁（Shared Locks）和排他锁(Exclusive Locks）。共享锁（S锁）允许多个事务同时读取同一数据，但阻止任何事务进行写操作（包括改事务自身）。 排他锁（X锁），又称写锁，当一个事务持有排他锁时，其他事务不能读取也不能写入被锁定的数据。 ‍","tags":["MySQL"],"categories":["数据库"]},{"title":"Git使用指南","path":"/2023/05/23/2023.05.23.057.Git使用指南/","content":"Git版本控制其实版本控制在我们的生活中无处不在，比如你的期末或是毕业答辩论文，由于你写得不规范或是老师不满意，你的老师可能会让你改了又改，于是就会出现很多版本的文件名，各种（1）（1）。。。 我们手里的论文可能会经过多次版本迭代，最终我们会选取一个最好的版本作为最终提交的论文。使用版本控制不仅仅是为了去记录版本迭代历史，更是为了能够随时回退到之前的版本，实现时间回溯。同时，可能我们的论文是多个人一同完成，那么多个人如何去实现同步，如何保证每个人提交的更改都能够正常汇总，如何解决冲突，这些问题都需要一个优秀的版本控制系统来解决。 走进Git我们开发的项目，也需要一个合适的版本控制系统来协助我们更好地管理版本迭代，而Git正是因此而诞生的（有关Git的历史，这里就不多做阐述了，感兴趣的小伙伴可以自行了解，是一位顶级大佬在一怒之下只花了2周时间用C语言开发的，之后的章节还会遇到他） 首先我们来了解一下Git是如何工作的： 点击查看源网页 可以看到，它大致分为4个板块： 工作目录：存放我们正在写的代码（当我们新版本开发完成之后，就可以进行新版本的提交） 暂存区：暂时保存待提交的内容（新版本提交后会存放到本地仓库） 本地仓库：位于我们电脑上的一个版本控制仓库（存放的就是当前项目各个版本代码的增删信息） 远程仓库：位于服务器上的版本控制仓库（服务器上的版本信息可以由本地仓库推送上去，也可以从服务器抓取到本地仓库） 它是一个分布式的控制系统，因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。 通过这一系列操作，我们就可以实现每开发完一个版本或是一个功能，就提交一次新版本，这样，我们就可以很好地控制项目的版本迭代，想回退到之前的版本随时都可以回退，想查看新版本添加或是删除了什么代码，随时都可以查看。 安装Git首先请前往Git官网去下载最新的安装包：https://git-scm.com/download/win 这手把手演示一下如何安装Git环境。 安装完成后，需要设定用户名和邮箱来区分不同的用户： 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 基本命令介绍创建本地仓库我们可以将任意一个文件夹作为一个本地仓库，输入： 1git init 输入后，会自动生成一个.git目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。 创建成功后，我们可以查看一下当前的一个状态，输入： 1git status 如果已经成功配置为Git本地仓库，那么输入后可以看到： 123On branch masterNo commits yet 这表示我们还没有向仓库中提交任何内容，也就是一个空的状态。 添加和提交接着我们来看看，如何使用git来管理我们文档的版本，我们创建一个文本文档，随便写入一点内容，接着输入： 1git status 我们会得到如下提示： 12345Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\thello.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们将其添加到暂存区，那么它会自动变为被追踪状态： 1git add hello.txt #也可以 add . 一次性添加目录下所有的 再次查看当前状态： 123Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)\tnew file: hello.txt 现在文件名称的颜色变成了绿色，并且是处于Changes to be committed下面，因此，我们的hello.txt现在已经被添加到暂存区了。 接着我们来尝试将其提交到Git本地仓库中，注意需要输入提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容： 1git commit -m &#x27;Hello World&#x27; 接着我们可以查看我们的提交记录： 12git loggit log --graph 我们还可以查看最近一次变更的详细内容： 1git show [也可以加上commit ID查看指定的提交记录] 再次查看当前状态，已经是清空状态了： 12On branch masternothing to commit, working tree clean 接着我们可以尝试修改一下我们的文本文档，由于当前文件已经是被追踪状态，那么git会去跟踪它的变化，如果说文件发生了修改，那么我们再次查看状态会得到下面的结果： 1234Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)\tmodified: hello.txt 也就是说现在此文件是处于已修改状态，我们如果修改好了，就可以提交我们的新版本到本地仓库中： 12git add .git commit -m &#x27;Modify Text&#x27; 接着我们来查询一下提交记录，可以看到一共有两次提交记录。 我们可以创建一个.gitignore文件来确定一个文件忽略列表，如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查： 12345678910# 这样就会匹配所有以txt结尾的文件*.txt# 虽然上面排除了所有txt结尾的文件，但是这个不排除!666.txt# 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略test/# 目录中所有以txt结尾的文件，但不包括子目录xxx/*.txt# 目录中所有以txt结尾的文件，包括子目录xxx/**/*.txt 创建后，我们来看看是否还会检测到我们忽略的文件。 回滚当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态： 1git reset --hard commitID 执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。 那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录： 1git reflog 这样就能找到之前的commitID，再次重置即可。 分支分支就像我们树上的一个树枝一样，它们可能一开始的时候是同一根树枝，但是长着长着就开始分道扬镳了，这就是分支。我们的代码也是这样，可能一开始写基础功能的时候使用的是单个分支，但是某一天我们希望基于这些基础的功能，把我们的项目做成两个不同方向的项目，比如一个方向做Web网站，另一个方向做游戏服务端。 因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。 创建分支我们可以通过以下命令来查看当前仓库中存在的分支： 1git branch 我们发现，默认情况下是有一个master分支的，并且我们使用的也是master分支，一般情况下master分支都是正式版本的更新，而其他分支一般是开发中才频繁更新的。我们接着来基于当前分支创建一个新的分支： 123git branch test# 对应的删除分支是git branch -d yyds 现在我们修改一下文件，提交，再查看一下提交日志： 1git commit -a -m &#x27;branch master commit&#x27; 通过添加-a来自动将未放入暂存区的已修改文件放入暂存区并执行提交操作。查看日志，我们发现现在我们的提交只生效于master分支，而新创建的分支并没有发生修改。 我们将分支切换到另一个分支： 1git checkout test 我们会发现，文件变成了此分支创建的时的状态，也就是说，在不同分支下我们的文件内容是相互隔离的。 我们现在再来提交一次变更，会发现它只生效在yyds分支上。我们可以看看当前的分支状态： 1git log --all --graph 合并分支我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支： 1git checkout master 接着使用分支合并命令： 1git merge test 会得到如下提示： 123Auto-merging hello.txtCONFLICT (content): Merge conflict in hello.txtAutomatic merge failed; fix conflicts and then commit the result. 在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？ 我们可以查看一下是哪里发生了冲突： 1git diff 因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。 变基分支除了直接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置： 1git rebase master 变基后，yyds分支相当于同步了此前master分支的全部提交。 优选我们还可以选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick： 1git cherry-pick &lt;commit id&gt;:单独合并一个提交 这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。 使用IDEA版本控制虽然前面我们基本讲解了git的命令行使用方法，但是没有一个图形化界面，始终会感觉到很抽象，所以这里我们使用IDEA来演示，IDEA内部集成了git模块，它可以让我们的git版本管理图形化显示，当然除了IDEA也有一些独立的软件比如：SourceTree（挺好用） 打开IDEA后，找到版本控模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，而我们编写的所有代码和项目目录下其他的文件都可以进行版本控制。 我们发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我们进行第一次初始化提交，提交之后我们可以在下方看到所有的本地仓库提交记录。 接着我们来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加到Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。 接着我们来演示一下分支创建和分支管理。 远程仓库远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。 远程仓库有公有和私有的，公有的远程仓库有GitHub、码云、Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，我们国内连接可能会有一点卡。私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。 这里我们以GitHub做讲解，官网：https://github.com，首先完成用户注册。 远程账户认证和推送接着我们就可以创建一个自定义的远程仓库了。 创建仓库后，我们可以通过推送来将本地仓库中的内容推送到远程仓库。 12git remote add 名称 远程仓库地址git push 远程仓库名称 本地分支名称[:远端分支名称] 注意push后面两个参数，一个是远端名称，还有一个就是本地分支名称，但是如果本地分支名称和远端分支名称一致，那么不用指定远端分支名称，但是如果我们希望推送的分支在远端没有同名的，那么需要额外指定。推送前需要登陆账户，GitHub现在不允许使用用户名密码验证，只允许使用个人AccessToken来验证身份，所以我们需要先去生成一个Token才可以。 推送后，我们发现远程仓库中的内容已经与我们本地仓库中的内容保持一致了，注意，远程仓库也可以有很多个分支。 但是这样比较麻烦，我们每次都需要去输入用户名和密码，有没有一劳永逸的方法呢？当然，我们也可以使用SSH来实现一次性校验，我们可以在本地生成一个rsa公钥： 12ssh-keygen -t rsacat ~/.ssh/github.pub 接着我们需要在GitHub上上传我们的公钥，当我们再次去访问GitHub时，会自动验证，就无需进行登录了，之后在Linux部分我们会详细讲解SSH的原理。 接着我们修改一下工作区的内容，提交到本地仓库后，再推送到远程仓库，提交的过程中我们注意观察提交记录： 1234git commit -a -m &#x27;Modify files&#x27;git log --all --oneline --graphgit push origin master git log --all --oneline --graph 我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了： 12git push --set-upstream origin master:mastergit push origin 在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的） 克隆项目如果我们已经存在一个远程仓库的情况下，我们需要在远程仓库的代码上继续编写代码，这个时候怎么办呢？ 我们可以使用克隆操作来将远端仓库的内容全部复制到本地： 1git clone 远程仓库地址 这样本地就能够直接与远程保持同步。 抓取、拉取和冲突解决我们接着来看，如果这个时候，出现多个本地仓库对应一个远程仓库的情况下，比如一个团队里面，N个人都在使用同一个远程仓库，但是他们各自只负责编写和推送自己业务部分的代码，也就是我们常说的协同工作，那么这个时候，我们就需要协调。 比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交： 12git fetch 远程仓库 #抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交git pull 远程仓库 #拉取：获取+合并 在程序员B拉取了最新的版本后，再编写自己的代码然后提交就可以实现多人合作编写项目了，并且在拉取过程中就能将别人提交的内容同步到本地，开发效率大大提升。 如果工作中存在不协调的地方，比如现在我们本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hello.txt并直接提交，会得到如下错误： 12345678To https://github.com/xx/xxx.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &#x27;https://github.com/xx/xxx.git&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 一旦一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。 如果远程仓库中的提交和本地仓库中的提交没有去编写同一个文件，那么就可以直接拉取： 1git pull 远程仓库 拉取后会自动进行合并，合并完成之后我们再提交即可。 但是如果两次提交都修改了同一个文件，那么就会遇到和多分支合并一样的情况，在合并时会产生冲突，这时就需要我们自己去解决冲突了。","tags":["Git"],"categories":["指南"]},{"title":"38.二叉树的中序遍历","path":"/2022/12/15/2022.12.15.056.(Algo)二叉树的中序遍历/","content":"94. Binary Tree Inorder Traversal（Easy）题目描述给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 12输入：root = [1,null,2,3]输出：[1,3,2] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;&#x3D; Node.val &lt;&#x3D; 100 思路和前序遍历方法类似，注意添加值代码的位置，即可容易的写出前中后序遍历。 创建一个列表集合，使用二叉树遍历框架，在前序位置编辑添加元素值的代码，执行即可。 上面是递归法。用迭代法也可以做。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; //递归法 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new LinkedList&lt;&gt;(); if(root==null) return res; res.addAll(preorderTraversal(root.left)); res.add(root.val); res.addAll(preorderTraversal(root.right)); return res; &#125; //迭代法 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result=new ArrayList&lt;&gt;(); if(root==null) return result; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); TreeNode cur=root; while(cur!=null||!stack.isEmpty())&#123; if(cur!=null)&#123; stack.push(cur); cur=cur.left; &#125;else&#123; cur=stack.pop(); result.add(cur.val); cur=cur.right; &#125; &#125; return result; &#125; //统一迭代法：注意节点入栈的顺序，前序是右左中null，中序为右中null左，后序为中null右左 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.peek(); if (node != null) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 &#125; &#125; return result; &#125;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","二叉树"],"categories":["LeetCode"]},{"title":"windows安装多python环境配置","path":"/2022/12/06/2022.12.06.055.windows安装多python环境配置/","content":"windows安装多python环境配置将多个版本python安装在一个目录下，统一管理，例如： D:\\ALL_Python\\python36 D:\\ALL_Python\\python37 D:\\ALL_Python\\python38 且为所有用户安装​（这样add path会写入系统环境变量） ‍核心： 配置多个环境变量，系统环境变量-Path​，里面有两个路径（安装python是勾选了add path，不然需要手动添加）： D:\\ALL_Python\\python36​这是python.exe​目录， D:\\ALL_Python\\python36\\Scripts​这是对应的pip.exe​目录。 在每个版本的安装目录下，将python.exe​改名为对应的版本，即python36.exe​，之后使用命令则使用修改后的对应版本的命令，即python36 -V​可查看版本（注意：重启终端，需要重启终端） 这里需要重新安装pip，然后改pip.exe​为pip37.exe​，之后使用pip的指令变为pip37 insatll packname​ 重装指令：python36 -m pip install --upgrade pip --force-reinstall​ 设置全局pip国内源：pip config set global.index-https://pypi.tuna.tsinghua.edu.cn/simple​,这里设置豆瓣源 至此全部完成。‍","tags":["Python"],"categories":["config"]},{"title":"JVM原理-类加载","path":"/2022/11/14/2022.11.14.054.JVM原理之类加载机制/","content":"类加载子系统内存结构概述image image​ ‍ ‍ 类加载器与类的加载过程类加载器子系统作用： 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。 ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 加载的类信息存放于一块称为方法区的内存空间​。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射） image​ 类加载器ClassLoader角色 class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。 class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。 在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。 image 类加载过程image​ 加载阶段加载： 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象​，作为方法区这个类的各种数据的访问入口 JDK8：Class对象存放在堆区，类的元数据存在方法区（元空间），元数据≠类的Class对象！Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等在方法区（元空间） 加载class文件的方式： 从本地系统中直接加载 通过网络获取，典型场景：Web Applet 从zip压缩包中读取，成为日后jar、war格式的基础 运行时计算生成，使用最多的是：动态代理技术 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见 从加密文件中获取，典型的防Class文件被反编译的保护措施 链接阶段链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析 image​ 验证(Verify) 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 准备(Prepare) 为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中 解析(Resolve) 将常量池内的符号引用转换为直接引用的过程 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等 初始化阶段类的初始化时机 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（比如：Class.forName(“com.atguigu.Test”)） 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法） clinit() 初始化阶段就是执行类构造器方法&lt;clinit&gt;()​的过程 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法 &lt;clinit&gt;()​方法中的指令按语句在源文件中出现的顺序执行 &lt;clinit&gt;()​不同于类的构造器。（关联：构造器是虚拟机视角下的&lt;init&gt;()​） 若该类具有父类，JVM会保证子类的&lt;clinit&gt;()​执行前，父类的&lt;clinit&gt;()​已经执行完毕 虚拟机必须保证一个类的&lt;clinit&gt;()​方法在多线程下被同步加锁 IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度 类加载器分类概述 JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader） 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示 image​ 虚拟机自带的加载器启动类加载器 启动类加载器（引导类加载器，Bootstrap ClassLoader） 这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部 它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类 并不继承自java.lang.ClassLoader，没有父加载器 加载扩展类和应用程序类加载器，并作为他们的父类加载器 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 扩展类加载器 扩展类加载器（Extension ClassLoader） Java语言编写，由sun.misc.Launcher$ExtClassLoader实现 派生于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载 系统类加载器 应用程序类加载器（也称为系统类加载器，AppClassLoader） Java语言编写，由sun.misc.LaunchersAppClassLoader实现 派生于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 通过classLoader.getSystemclassLoader()方法可以获取到该类加载器 用户自定义类加载器什么时候需要自定义类加载器？在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？ 隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的） 修改类加载的方式 扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方） 防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密） 如何自定义类加载器？ 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。 123456789101112131415161718192021222324252627282930313233343536public class CustomClassLoader extends ClassLoader &#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; byte[] result = getClassFromCustomPath(name); if (result == null) &#123; throw new FileNotFoundException(); &#125; else &#123; //defineClass和findClass搭配使用 return defineClass(name, result, 0, result.length); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; throw new ClassNotFoundException(name); &#125;\t//自定义流的获取方式 private byte[] getClassFromCustomPath(String name) &#123; //从自定义路径中加载指定类:细节略 //如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。 return null; &#125; public static void main(String[] args) &#123; CustomClassLoader customClassLoader = new CustomClassLoader(); try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;One&quot;, true, customClassLoader); Object obj = clazz.newInstance(); System.out.println(obj.getClass().getClassLoader()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ClassLoader的使用说明 ClassLoader 类介绍 ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器） image​ sun.misc.Launcher 它是一个java虚拟机的入口应用 image​ 获取ClassLoader途径image​ 1234567891011121314151617181920212223public class ClassLoaderTest2 &#123; public static void main(String[] args) &#123; try &#123; //1. ClassLoader classLoader = Class.forName(&quot;java.lang.String&quot;).getClassLoader(); System.out.println(classLoader); //2. ClassLoader classLoader1 = Thread.currentThread().getContextClassLoader(); System.out.println(classLoader1); //3. ClassLoader classLoader2 = ClassLoader.getSystemClassLoader().getParent(); System.out.println(classLoader2); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//######################输出结果#######################//null//sun.misc.Launcher$AppClassLoader@18b4aac2//sun.misc.Launcher$ExtClassLoader@1540e19d 双亲委派机制双亲委派机制原理Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行； 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器； 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常 image​ 双亲委派机制代码演示举例1 1、我们自己建立一个 java.lang.String 类，写上 static 代码块 123456public class String &#123; // static&#123; System.out.println(&quot;我是自定义的String类的静态代码块&quot;); &#125;&#125; 2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类 12345678910public class StringTest &#123; public static void main(String[] args) &#123; java.lang.String str = new java.lang.String(); System.out.println(&quot;hello,atguigu.com&quot;); StringTest test = new StringTest(); System.out.println(test.getClass().getClassLoader()); &#125;&#125; 输出结果： 12hello,atguigu.comsun.misc.Launcher$AppClassLoader@18b4aac2 程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。 把刚刚的类改一下 123456789package java.lang;public class String &#123; static&#123; System.out.println(&quot;我是自定义的String类的静态代码块&quot;); &#125; //错误: 在类 java.lang.String 中找不到 main 方法 public static void main(String[] args) &#123; System.out.println(&quot;hello,String&quot;); &#125; image​ 由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。 举例2123456package java.lang;public class ShkStart &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 输出结果： 1234567891011121314151617java.lang.SecurityException: Prohibited package name: java.lang\tat java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)\tat java.lang.ClassLoader.defineClass(ClassLoader.java:761)\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)\tat java.security.AccessController.doPrivileged(Native Method)\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335)\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\tat sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)Error: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; Process finished with exit code 1 即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制 举例3当我们加载jdbc.jar 用于实现数据库连接的时候 我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api 然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了 具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】 第三方的jar包中的类属于系统类加载器来加载 从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载 image​ 双亲委派机制优势通过上面的例子，我们可以知道，双亲机制可以 避免类的重复加载 保护程序安全，防止核心API被随意篡改 自定义类：自定义java.lang.String 没有被加载。 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类） 沙箱安全机制 自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。 这样可以保证对java核心源代码的保护，这就是沙箱安全机制。 其他如何判断两个class对象是否相同？在JVM中表示两个class对象是否为同一个类存在两个必要条件： 类的完整类名必须一致，包括包名 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的 对类加载器的引用 JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的 ‍","tags":["JVM"],"categories":["Java"]},{"title":"37.不同路径 II","path":"/2022/11/12/2022.11.12.053.(Algo)不同路径 II/","content":"63. Unique Paths II（Medium）题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1： 123456输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 12输入：obstacleGrid = [[0,1],[0,0]]输出：1 提示： m &#x3D;&#x3D; obstacleGrid.length n &#x3D;&#x3D; obstacleGrid[i].length 1 &lt;&#x3D; m, n &lt;&#x3D; 100 obstacleGrid[i] [j] 为 0 或 1 思路本题思路和62题不同路径相同。 所以使用动态规划。 确定dp数组（dp table）以及下标的含义：dp [ i ] [ j ] ：表示从（0 ，0）出发，到(i, j) 有dp [ i ] [ j ] 条不同的路径。 确定递推公式：想要求dp [ i ] [ j ]，只能有两个方向来推导出来，即dp [ i -1] [ j ]和 dp [ i ] [ j -1]。此时在回顾一下dp [ i -1] [ j ]表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp [ i ] [ j -1]同理。那么很自然，dp [ i ] [ j ] &#x3D; dp [ i -1] [ j ]+ dp [ i ] [ j -1]，因为dp [ i ] [ j ] 只有这两个方向过来。注意要判断是否有障碍物，没有才能递推下去。 dp数组的初始化：首先dp [ i ] [ 0 ]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp [0] [j]也同理。但这里注意得判断是否有障碍物，如果有障碍物，则后续位置都无法达到，直接赋值0.所以初始化代码为 for (int i=0;i&lt;m &amp;&amp; obstacleGrid[i][0]==0;i++) dp[i][0] = 1; for (int j=0;j&lt;n &amp;&amp; obstacleGrid[0][j]==0;j++) dp[0][j] = 1; 确定遍历顺序:这里要看一下递推公式dp[i] [j] &#x3D; dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。 代码实现12345678910111213141516171819202122public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m=obstacleGrid.length; int n=obstacleGrid[0].length; int[][] dp=new int[m][n];\t//在起点或终点出现了障碍，直接返回0 if(obstacleGrid[m-1][n-1]==1||obstacleGrid[0][0]==1) return 0;\t//初始化 for(int i=0;i&lt;m &amp;&amp; obstacleGrid[i][0]==0;i++)&#123; dp[i][0]=1; &#125; for(int j=0;j&lt;n &amp;&amp; obstacleGrid[0][j]==0;j++)&#123; dp[0][j]=1; &#125;\t//求到达每个点的路径数量 for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; //判断当前位置是否有障碍物，没有才能推导，否则赋值0 dp[i][j]=(obstacleGrid[i][j]==0)?dp[i][j-1]+dp[i-1][j]:0; &#125; &#125;return dp[m-1][n-1];&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","Dynamic"],"categories":["LeetCode"]},{"title":"36.不同路径","path":"/2022/11/11/2022.11.11.052.(Algo)不同路径/","content":"62. Unique Paths（Medium）题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？示例 1： 12输入：m = 3, n = 7输出：28 示例 2： 1234567输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下 示例 3： 12输入：m = 7, n = 3输出：28 示例 4： 12输入：m = 3, n = 3输出：6 提示： 1 &lt;&#x3D; m, n &lt;&#x3D; 100 题目数据保证答案小于等于 2 * 109 思路使用深度搜索会超时，其相当于遍历整个二叉树（路径抽象为二叉树，即求叶子结点），其深度就为m+n-1（mxn的格子，深度按从1开始计算），二叉树节点为2^(m+n-1)-1，所以时间复杂度为O(2^(m+n-1)-1)。 所以使用动态规划。 确定dp数组（dp table）以及下标的含义：dp [ i ] [ j ] ：表示从（0 ，0）出发，到(i, j) 有dp [ i ] [ j ] 条不同的路径。 确定递推公式：想要求dp [ i ] [ j ]，只能有两个方向来推导出来，即dp [ i -1] [ j ]和 dp [ i ] [ j -1]。此时在回顾一下dp [ i -1] [ j ]表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp [ i ] [ j -1]同理。那么很自然，dp [ i ] [ j ] &#x3D; dp [ i -1] [ j ]+ dp [ i ] [ j -1]，因为dp [ i ] [ j ] 只有这两个方向过来。 dp数组的初始化：如何初始化呢，首先dp [ i ] [ 0 ]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp [0] [j]也同理。所以初始化代码为 for (int i = 0; i &lt; m; i++) dp[i][0] = 1; for (int j = 0; j &lt; n; j++) dp[0][j] = 1; 确定遍历顺序:这里要看一下递推公式dp[i] [j] &#x3D; dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。 代码实现12345678910111213public int uniquePaths(int m, int n) &#123; int[][] dp=new int[m][n];\t//初始化 for(int i=0;i&lt;m;i++) dp[i][0]=1; for(int i=0;i&lt;n;i++) dp[0][i]=1;\t//遍历到达每个位置的可能的路径数 for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[i][j]=dp[i-1][j]+dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125; 来源： 力扣（LeetCode） 代码随想录","tags":["Algorithms","Dynamic"],"categories":["LeetCode"]},{"title":"35.四数之和","path":"/2022/10/31/2022.10.31.051.(Algo)四数之和/","content":"18. 4Sum（Medium）题目描述给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组[nums[a], nums[b], nums[c], nums[d]]（若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;&#x3D; a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target 你可以按 任意顺序 返回答案 。示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;&#x3D; nums.length &lt;&#x3D; 200 109 &lt;&#x3D; nums[i] &lt;&#x3D; 109 109 &lt;&#x3D; target &lt;&#x3D; 109 思路四数之和，和15.三数之和 (opens new window)是一个思路，都是使用双指针法, 基本解法就是在15.三数之和 (opens new window) 的基础上再套一层for循环。 同时需要注意target值不再固定为0，所以需要更改判断条件nums[k]&gt;target，if(nums[i]&gt;0&amp;&amp;nums[i]&gt;target) return result;当排完序后的第一个数值&gt;0并且大于target，直接返回结果。 其他的操作和三数之和一样。通过双指针，将暴力循环解法的时间复杂度从(n^4) 降为O(n^3)。同理，三数之和双指针解法将将暴力循环解法的时间复杂度从 (n^3) 降为O(n^2)。类比可以得出，双指针法将时间复杂度： O(n^2)的解法优化为 O(n)的解法。也就是降一个数量级。 代码实现12345678910111213141516171819202122232425262728293031323334353637public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result =new ArrayList&lt;&gt;(); Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++)&#123; //nums[i]&gt;target 直接返回，剪枝操作 if(nums[i]&gt;0&amp;&amp;nums[i]&gt;target) return result; //对第一个数进行判断是否重复，重复则跳过当前循环 if(i&gt;0&amp;&amp;nums[i-1]==nums[i]) continue; //以下相当于 三数之和 解法 for(int j=i+1;j&lt;nums.length;j++)&#123; //对第二个数进行判断是否重复，注意是当前数和前一位作比较 if(j&gt;i+1 &amp;&amp; nums[j-1]==nums[j]) continue; int left=j+1; int right=nums.length-1; while(right&gt;left)&#123; long sum=(long)nums[i]+nums[j]+nums[left]+nums[right]; if(sum&gt;target)&#123; right--; &#125;else if(sum&lt;target)&#123; left++; &#125;else&#123; result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); // 对nums[left]和nums[right]去重 while(right&gt;left&amp;&amp;nums[right]==nums[right-1]) right--; while(right&gt;left&amp;&amp;nums[left]==nums[left+1]) left++; // 找到答案时，双指针同时收缩 left++; right--; &#125; &#125; &#125; &#125; return result;&#125; 来源： 力扣（LeetCode） 代码随想录","tags":["Algorithms","双指针"],"categories":["LeetCode"]},{"title":"34.三数之和","path":"/2022/10/22/2022.10.22.050.(Algo)三数之和/","content":"15. 3Sum（Easy）（Medium）（Hard）题目描述给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。 示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2： 123输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3： 123输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示：3 &lt;&#x3D; nums.length &lt;&#x3D; 3000-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105 思路本题需要在给定的整数数组中找到三个值相加为0，且这组值不能重复。采用哈希法，用for循环求得a+b的值，然后另一个for循环判断0-(a+b)是否在数组中，可以求解，但是问题需要结果去重。会很耗时间。 这里采用双指针方法实现：对数组进行排序，然后for循环定义int i，left，right。判断三个指针对应的数值相加，若大于0，则right--（最大值减小才有可能让和为0）；若小于0，则left++。 关键在于三个数字的去重。对于第一个，也就是循环变量i，应该判断nums[i]==nums[i-1]，即当前值与前一个值做比较，才不会让后面有可能的值pass，例如&#123;-1，-1,2&#125;，i指向第一个-1时，应该判断的是其与前一个值是否相同，而不是与后一个值，不然会pass掉&#123;-1，-1,2&#125;这组结果。对于left和right来说，是存在三个数和为0后才移动其值，所以放在添加结果后进行判断，不然会漏掉可能的结果。 代码实现123456789101112131415161718192021222324252627282930313233343536public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); //对nums进行排序 Arrays.sort(nums); for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i]&gt;0)&#123; return result; &#125; //对第一个数进行去重，&#123;-1，-1,2&#125;，指向第一个-1时， //应该判断的是其与前一个值是否相同，而不是与后一个值，不然会pass掉&#123;-1，-1,2&#125;这组结果 if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123; continue; &#125; int left=i+1; int right=nums.length-1; while(right&gt;left)&#123; int sum=nums[i]+nums[left]+nums[right]; if(sum&gt;0)&#123; right--; &#125;else if(sum&lt;0)&#123; left++; &#125;else&#123; result.add(Arrays.asList(nums[i],nums[left],nums[right])); //对第二个和第三个值进行去重 while(right&gt;left&amp;&amp;nums[right]==nums[right-1]) right--; while(right&gt;left&amp;&amp;nums[left]==nums[left+1]) left++; right--; left++; &#125; &#125; &#125; return result;&#125; 来源： 力扣（LeetCode） 代码随想录B站讲解","tags":["Algorithms","双指针"],"categories":["LeetCode"]},{"title":"33. 赎金信","path":"/2022/10/22/2022.10.22.049.(Algo)赎金信/","content":"383. Ransom Note（Easy）题目描述给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示： 1 &lt;&#x3D; ransomNote.length, magazine.length &lt;&#x3D; 105ransomNote 和 magazine 由小写英文字母组成 思路关键点：小写字母，magazine中的每个字符只能使用一次。创建哈希映射数组record，将magazine中的每个字符数量添加进record中，然后遍历ransomNote中的字符，并在record中减去出现的字符。最后判断record中是否存在负数，存在则说明magazine中字符不够用。 代码实现12345678910111213141516171819public boolean canConstruct(String ransomNote, String magazine) &#123; //哈希映射数组，存放出现的字符数量 int[] record=new int[26]; for(char s:magazine.toCharArray())&#123; record[s-&#x27;a&#x27;]+=1; &#125; for(char s:ransomNote.toCharArray())&#123; record[s-&#x27;a&#x27;]-=1; &#125; //数组中存在负数，则说明ransomNote字符中存在magazine没有的字符 for(int i:record)&#123; if(i&lt;0)&#123; return false; &#125; &#125; return true;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","Hash"],"categories":["LeetCode"]},{"title":"32.四数相加 II","path":"/2022/10/22/2022.10.22.048.(Algo)四数相加-II/","content":"454. 4Sum II（Medium）题目描述给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;&#x3D; i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0 示例 1： 123456输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2： 12输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1 提示：n &#x3D;&#x3D; nums1.lengthn &#x3D;&#x3D; nums2.lengthn &#x3D;&#x3D; nums3.lengthn &#x3D;&#x3D; nums4.length1 &lt;&#x3D; n &lt;&#x3D; 200-228 &lt;&#x3D; nums1[i], nums2[i], nums3[i], nums4[i] &lt;&#x3D; 228 思路创建Map。四个数组，将前两个数组对应位置元素相加，充当Map的key，将其出现的次数当做value。后两个数组也对应位置元素相加，判断是0-其和在Map中是否存在，存在的话就是满足题目要求的。返回对应的value值即可。 代码实现123456789101112131415161718192021222324252627public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; //创建一个map，k值为nums1和nums2对应位置相加和，v值为这个结果出现的次数 Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); int temp; int times=0; //计算前两个数组相加和与和的次数 for(int i:nums1)&#123; for(int j:nums2)&#123; temp=i+j; if(map.containsKey(temp))&#123; map.put(temp,map.get(temp)+1); &#125;else&#123; map.put(temp,1); &#125; &#125; &#125; //计算后两个数组相加和，并判断map中是否存在与这两数和相加为0的值 for(int i:nums3)&#123; for(int j:nums4)&#123; temp=i+j; if(map.containsKey(0-temp))&#123; times+=map.get(0-temp); &#125; &#125; &#125; return times;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","HashMap"],"categories":["LeetCode"]},{"title":"31.快乐数","path":"/2022/10/22/047.(Algo).快乐数/","content":"202. Happy Number（Easy）题目描述编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 1234567输入：n = 19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 示例 2： 12输入：n = 2输出：false 提示：1 &lt;&#x3D; n &lt;&#x3D; 231 - 1 思路题目意思将给你的数字的每一位数字开平方并求和，代替原来的数字，重复下去，直到等于1时，这个数就是“快乐数”。在这个过程中可能存在无限循环，某一个数在之前的循环中出现过，导致环形重复。所以采用无重复数的Set集合来存放计算得到的值，只有当前数不为1并且当前数不在Set集合中时，循环获取下一个数。最后判断当前数是否等于1，等于返回true，否则false。 代码实现1234567891011121314151617181920public boolean isHappy(int n) &#123; Set&lt;Integer&gt; record = new HashSet&lt;&gt;(); //当前值不为1，并且Set中不包含当前值，才会进行计算下一个n值 while(n!=1 &amp;&amp; !record.contains(n))&#123; record.add(n); n=getNextNumber(n); &#125; return n==1;&#125;//计算下一个数值private int getNextNumber(int n)&#123; int res=0; while(n&gt;0)&#123; int temp=n%10;//得到当前数的个位数 res+=temp*temp;//对个位数进行平方 n=n/10;//减小位数 &#125; return res;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","HashSet"],"categories":["LeetCode"]},{"title":"30.两个数组的交集","path":"/2022/10/19/046.(Algo).两个数组的交集/","content":"349. Intersection of Two Arrays（Easy）题目描述给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 示例 2： 123输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的 提示： 1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 10000 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000 思路输出交集，结果顺序无所谓且元素唯一。可以采用Set来存放第一个数组元素，因为Set天然去重，然后依次遍历第二个数组，判断是否在哈希表中存在该元素，存在则说明有交集，将该元素放入结果集中，最后将结果集转化为数组输出。 代码实现1234567891011121314151617public int[] intersection(int[] nums1, int[] nums2) &#123; if(nums1==null||nums2==null||nums1.length==0||nums2.length==0) return new int[0]; Set&lt;Integer&gt; set1=new HashSet&lt;&gt;(); Set&lt;Integer&gt; resSet=new HashSet&lt;&gt;(); for(int i:nums1)&#123; set1.add(i); &#125; //遍历数组2的过程中判断哈希表中是否存在该元素 for(int i:nums2)&#123; if(set1.contains(i))&#123; resSet.add(i); &#125; &#125; return resSet.stream().mapToInt(x-&gt;x).toArray();&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","HashSet"],"categories":["LeetCode"]},{"title":"29.有效的字母异位词","path":"/2022/10/18/045.(Algo).有效的字母异位词/","content":"242. Valid Anagram（Easy）题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 提示: 1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104s 和 t 仅包含小写字母 思路单循环：一次循环判断完毕，创建一个arr数组，存放对应的字母的ASC码（这里是97-122），将两个字符串转化为字符数组；在一趟循环中进行两次判断，其判断的目的是为了统计字符串的长度。因为两个字符串字母顺序不一致，所以相当于加了锁，对S：将当前s字符数组的值加入arr后，其值&lt;&#x3D;0才统计count；对t：将当前t字符数组的值从arr减去后，其值&gt;&#x3D;0才统计count。 即： 1）第一个判断中用S串增加了一个a，导致a的数量&gt;0，就不会增加count的值，只有在第二个判断中用t串减去一个a，让a的值回归0时，对count++，相当于消除了； 2）第一个判断中用S串增加了多个a，导致a的数量&gt;0，就不会增加count的值，只有在第二个判断中用t串减去一个a，让a的值&gt;&#x3D;0时，对count++，相当于消除了； ————————————————————————分界线 双循环：创建一个记录数组record，包含26个下标（这里采用相对值，ASC码’a’对应97，当前字母-‘a’的值处于0-25）。第一个循环用s串对record数组初始化，使s串所有的字符数量进入数组；第二个循环用t串对record数组归零化，即减去相对应字母的数量；最后判断record数组中是否不存在0值，即有字母的数量不是0，则说明两个字符串不是异位词。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243//单循环public boolean isAnagram(String s, String t) &#123;\t//长度不等必定false if(s.length()!=t.length()) return false; int[] arr=new int[123]; char[] charS=s.toCharArray(); char[] charT=t.toCharArray(); int count =0; //单循环判断是否异位 for(int i=0;i&lt;s.length();i++)&#123; //对s串先进行++操作，之后判断其值是否&lt;=0，是则对count++ if(++arr[charS[i]]&lt;=0)&#123; count++; &#125; //对t串先进行--操作，之后判断其值是否&gt;=0，是则对count++ if(--arr[charT[i]]&gt;=0)&#123; count++; &#125; &#125; //比较count和s串的长度，即可得出是否为异位词 return count==s.length();&#125;//双循环public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length()) return false; int[] record = new int[26];\t//用s串对record数组初始化 for (int i = 0; i &lt; s.length(); i++) &#123; record[s.charAt(i) - &#x27;a&#x27;]++;//这里s.charAt(i) - &#x27;a&#x27;得到的即为相对位置，a的ASC码为97 &#125;\t//用t串对record数组归零化 for (int i = 0; i &lt; t.length(); i++) &#123; record[t.charAt(i) - &#x27;a&#x27;]--; &#125;\t//record中存在非0值，则说明某个字母还在record中，即不是异位词 for (int count: record) &#123; if (count != 0) &#123; return false; &#125; &#125; return true;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","HashSet"],"categories":["LeetCode"]},{"title":"28.环形链表 II","path":"/2022/10/18/044.(Algo)环形链表-II/","content":"142. Linked List Cycle II（Medium）题目描述给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示：链表中节点的数目范围在范围 [0, 104] 内-105 &lt;&#x3D; Node.val &lt;&#x3D; 105pos 的值为 -1 或者链表中的一个有效索引 思路首先明确一点：设置两个指针，一个快每次走两步，一个慢每次走一步，那么只要存在环，则一定会在环中相遇（推导证明可以百度）。其次是相遇后如何确定环的入口。看下图： 三个距离 x,y,z。相遇时，slow走过：x+y，fast走过：x+y+n(y+z)，n为fast在环内和slow相遇前走过的圈数。 slow每次走一步，fast每次走两步，所以有M(fast)=2*M(slow)，即(x + y) * 2 = x + y + n (y + z)，两边消掉一个（x+y）: x + y = n (y + z) 因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。 所以要求x ，将x单独放在左面：x = n (y + z) - y , 再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。 当 n为1的时候，公式就化解为 x = z，这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。 让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。 当 n&gt;1的时候，等同于index1在环内多转n-1圈后才会和index2相遇。 代码实现12345678910111213141516171819202122public class Solution&#123; public ListNode detectCycle(ListNode head)&#123; ListNode slow =head; ListNode fast =head; //有环则进入循环 while(fast!=null&amp;&amp;fast.next!=null)&#123; slow=slow.next;//慢指针每次走一步 fast=fast.next.next;//快指针每次走两步 if(slow==fast)&#123; ListNode index1=fast; ListNode index2=head; while(index1!=index2)&#123; index1=index1.next; index2=index2.next; &#125; return index1; &#125; &#125; return null; &#125;&#125; 来源： 力扣（LeetCode） 代码随想录","tags":["Algorithms","Link"],"categories":["LeetCode"]},{"title":"27.面试题 02.07. 链表相交","path":"/2022/09/29/043(Algo).面试题-02.07.-链表相交/","content":"面试题 02.07. Intersection of Two Linked Lists LCCI（Easy）题目描述给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &#x27;8&#x27;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 12345输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &#x27;2&#x27;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？ 思路找相交的起始位置，意思是从交点起，后续节点一样，也就是说存在相交，相交之后的长度是一样的。所以，先计算两个链表的长度，改变长链表的起始指针和短链表的头指针在倒着数的情况下长度相同。然后判断两个链表指针对应的元素是否相同，相同则返回该指针。 另一种思路：两个链表都从头开始向后走，判断下一个节点是否为null，为空的那个链表的下一个节点移动到另一个链表，然后接着走，直到两个节点指针相遇。具体证明过程百度搜索。可以简单的手画下过程，理解更清晰。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445//思路一public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode curA=headA; ListNode curB=headB; int lenA=0,lenB=0; //链表A长度 while(curA.next!=null)&#123; lenA++; curA.next=curA; &#125; //链表B长度 while(curB.next!=null)&#123; lenB++; curB.next=curB; &#125; //让curA为最长链表的头，lenA为其长度 if(lenB&gt;lenA)&#123; int tempLen=lenA; lenA=lenB; lenB=tempLen; ListNode tempNode=curA; curA=curB; curB=tempNode; &#125; //求长度差 int gap=lenA-lenB; while(gap--&gt;0) curA=curA.next;//尾巴对齐操作 //寻找值相等的节点 while(curA!=null)&#123; if(curA==curB) return curA; curA=curA.next; curB=curB.next; &#125; return null;&#125;//另一种思路public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null||headB==null) return null; ListNode pA=headA,pB=headB; while(pA!=pB)&#123; pA=pA==null?headB:headA.next; pB=pB==null?headA:headB.next; &#125; return pA;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","Link"],"categories":["LeetCode"]},{"title":"26.删除链表的倒数第 N 个结点","path":"/2022/09/29/042.(Algo).删除链表的倒数第-N-个结点/","content":"19. Remove Nth Node From End of List（Medium）题目描述给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz1 &lt;= sz &lt;= 300 &lt;= Node.val &lt;= 1001 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ 思路双指针，快慢指针，让快指针先走n步，然后慢指针和快指针一起走，直到快指针指向null，慢指针对应的节点就是要删除的节点。这里要注意，想要删除当前节点，需要直到当前节点的上一个节点，所以得让快指针先走n+1步，这样当快指针指向null时，慢指针指向待删除节点的前一个节点。 代码实现123456789101112131415161718public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummyHead=new ListNode(-1); dummyHead.next=head; ListNode fast=dummyHead; ListNode slow=dummyHead; //fast提前走n+1步 while(n--&gt;=0)&#123; fast=fast.next; &#125; //若写为fast.next!=null，则第7行循环条件得改为n--&gt;0 while(fast!=null)&#123; slow=slow.next; fast=fast.next; &#125; slow.next=slow.next.next; return dummyHead.next;&#125; 来源： [力扣（LeetCode）(https://leetcode.cn/problems/remove-nth-node-from-end-of-list)","tags":["Algorithms","Link"],"categories":["LeetCode"]},{"title":"25.两两交换链表中的节点","path":"/2022/09/29/041.(Algo)两两交换链表中的节点/","content":"24. Swap Nodes in Pairs（Medium）题目描述给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head = []输出：[] 示例 3： 12输入：head = [1]输出：[1] 提示：链表中节点的数目在范围 [0, 100] 内0 &lt;&#x3D; Node.val &lt;&#x3D; 100 思路交换节点，难点一是怎么确定循环的终止条件：这里设置了虚拟头结点dummyHead，然后可以得出dummyHead.next和dummyHead.next.next两个节点需要进行交换。再设置cur指向dummyHead，则只需要判断cur.next和cur.next.next连个节点都不为null即可。难点二在于进行交换时，前两个节点交换后，如何找到并连接后面的链表：这里设置temp指向第三个节点，每次循环都使其指向cur之后的第三个节点。 代码实现12345678910111213141516public ListNode swapPairs(ListNode head) &#123; ListNode dummyHead=new ListNode(0); dummyHead.next=head; ListNode cur=dummyHead; while(cur.next!=null&amp;&amp;cur.next.next!=null)&#123; //创建前两个需要反转节点之后节点的指向 ListNode temp=head.next.next; cur.next=head.next; head.next.next=head.next; head.next=temp; cur=head; head=head.next; &#125; return dummyHead.next;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","Link"],"categories":["LeetCode"]},{"title":"23.设计链表","path":"/2022/09/27/040.(Algo)设计链表/","content":"707.Design Linked List（Medium）题目描述设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例： 1234567MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3linkedList.get(1); //返回2linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3linkedList.get(1); //返回3 提示：0 &lt;&#x3D; index, val &lt;&#x3D; 1000请不要使用内置的 LinkedList 库。get, addAtHead, addAtTail, addAtIndex 和 deleteAtIndex 的操作次数不超过 2000。 思路中规中矩的链表设计题。这里使用了虚拟头结点，用带index的插入方式实现了头插法和尾插法。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class ListNode&#123; int val; ListNode next; ListNode()&#123;&#125; ListNode(int val)&#123; this.val=val; &#125;&#125;class MyLinkedList &#123; //存储链表元素的个数 int size; //虚拟头结点 ListNode head; //初始化链表 public MyLinkedList() &#123; size=0; head=new ListNode(0); &#125; //获取第index个节点的值 public int get(int index) &#123; if(index&lt;0||index&gt;=size)&#123; return -1; &#125; ListNode currentNode=head; for(int i=0;i&lt;=index;i++)&#123; currentNode=currentNode.next; &#125; return currentNode.val; &#125; //头插法，即在第0个节点之前插入值val public void addAtHead(int val) &#123; addAtIndex(0,val); &#125; //尾插法，即在第size个节点之前插入值val public void addAtTail(int val) &#123; addAtIndex(size,val); &#125; //在第index个节点之前插入值val public void addAtIndex(int index, int val) &#123; if(index&gt;size) return; if(index&lt;0) index=0; size++; ListNode pred=head; for(int i=0;i&lt;index;i++)&#123; pred=pred.next; &#125; ListNode toAdd=new ListNode(val); toAdd.next=pred.next; pred.next=toAdd; &#125; //删除第index个节点 public void deleteAtIndex(int index) &#123; if(index&lt;0||index&gt;=size) return; size--; if(index==0)&#123; head=head.next; return; &#125; ListNode pred=head; for(int i=0;i&lt;index;i++)&#123; pred=pred.next; &#125; pred.next=pred.next.next; &#125;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","Link"],"categories":["LeetCode"]},{"title":"22.移除链表元素","path":"/2022/09/27/039.(Algo)移除链表元素/","content":"203. Remove Linked List Eelements（Easy）题目描述给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。 示例 1： 12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 12输入：head = [], val = 1输出：[] 示例 3： 12输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内1 &lt;&#x3D; Node.val &lt;&#x3D; 500 &lt;&#x3D; val &lt;&#x3D; 50 思路简单的链表操作，采用递归和迭代都可以实现。 代码实现123456789101112131415161718192021//迭代public ListNode removeElements(ListNode head, int val) &#123;\tif(head==null) return head;//判断是否为空，空则直接返回。可以省略这句。\tListNode dummyHead=new ListNode(0);\tdummyHead.next=head;//设置一个头结点，方便后续操作\tListNode temp=dummyHead; while(temp.next!=null)&#123; if(temp.next.val==val)&#123; temp.next=temp.next.next; &#125;else&#123; temp=temp.next; &#125; &#125; return dummyHead.next;&#125;//递归public ListNode removeElements(ListNode head, int val) &#123; if(head==null) return head; head.next=removeElements(head.next,val); return head.val==val?head.next:head;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","Link"],"categories":["LeetCode"]},{"title":"21.螺旋矩阵 II","path":"/2022/09/26/038.(Algo)螺旋矩阵-II/","content":"59. Spiral Matrix II（Medium）题目描述给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： 12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 12输入：n = 1输出：[[1]] 提示：1 &lt;&#x3D; n &lt;&#x3D; 20 思路题目意思就是给一个n x n的矩阵填充数字，范围为1到n^2。首先决定填充的时候循环变量如何确定，即如何处理转角的值。这里采用左闭右开区间 [) ，即转角元素计入下一条边，在本边处理时不包括转角。其次，循环圈数确定，因为是正方形，循环一圈上下左右都会向内缩进1，即每循环一圈，上下共计缩进2，左右也缩进2，故而循环圈数为n/2。还要考虑到n为奇数的情况，即循环到最里层，只剩下一个位置需要填充。 代码实现1234567891011121314151617181920212223242526272829303132public int[][] generateMatrix(int n) &#123; int loop=0;//控制循环次数 int[][] res=new int[n][n]; int start=0;//每次循环开始点（start，start） int count=1;//定义填充数字 int i,j; while(loop++&lt;n/2)&#123;//判断边界后，loop从1开始 //模拟上侧从左到右 for(j=start;j&lt;n-loop;j++)&#123; res[start][j]=count++; &#125; //模拟右侧从上到下，此时j无需更新，i需更新 for(i=start;i&lt;n-loop;i++)&#123; res[i][j]=count++; &#125; //模拟下侧从右到左，此时j需更新，i无需更新 for(;j&gt;=loop;j--)&#123; res[i][j]=count++; &#125; //模拟左侧从下到上，此时j无需更新，i需更新 for(;i&gt;=loop;i--)&#123; res[i][j]=count++; &#125; start++;//一圈循环完毕，下一圈更新时，初始位置需更新 &#125; //n为奇数时，最里层会有一个剩余，此时填充count的值进去 if(n%2==1) res[start][start]=count; return res;&#125; 来源： 力扣（LeetCode） 代码随想录","tags":["Algorithms","Link"],"categories":["LeetCode"]},{"title":"并发相关知识点（一）","path":"/2022/09/26/2022.09.27并发相关知识点/","content":"并发相关知识点&amp;问题并发三个核心分工、同步&#x2F;协作、互斥 问题： 工作中多线程编程的场景多吗？ 想到多线程，你只能想到synchronized吗？ Java并发包各个类，你有了解底层实现和设计理念吗？ 并发Bug之源可见性、原子性、有序性 问题： 为什么用final修饰的变量就是线程安全的了呢？ 你会经常查看CPU汇编指令吗？ 如果让你写单例，你通常会采用哪种实现？ Happens-before原则解决可见性和有序性规则一：volatile写 之前的操作 不能重排到 volatile写之后； 规则二：volatile读 之后的操作 不能重排到 volatile读之前； 规则三：传递性规则，A happens-before B，且B happens-before C，则A happens-before C； 监视器锁规则：对于一个锁的解锁 happens-before 于随后对这个锁的加锁。 start()规则：主线程A 启动 子线程B（ThreadB.start()），则B可以看到B启动前的操作。 join()规则：线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before 于线程A从ThreadB.join()操作成功返回，即b完成后，主线程能看到子线程B的赋值操作。 问题： 同步块和同步方法在编译成CPU指令后有什么不同？ 线程有Daemon(守护线程)和非Daemon线程，你知道线程的退出策略吗？ 关于Happens-before你还有哪些疑惑？ 原子性问题源头是 线程切换 互斥：同一时刻只有一个线程执行。 加锁 问题： 多个锁 锁一个资源一定会有问题吗？ 什么时候需要锁小区，而不能锁某一户呢？ 银行转账，两人互转和别人给自己转，用什么样的锁粒度合适呢？ volatile关键字 第二个操作 第二个操作 第二个操作 第一个操作 能否重写 普通读写 volatile读 volatile写 第一个操作 普通读写 - - NO 第一个操作 volatile读 NO NO NO 第一个操作 volatile写 - NO NO 在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障 在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障 在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障 在每个 volatile 读操作的后⾯插⼊⼀个 LoadStore 屏障 问题： 如果volatile写之后直接return，那还会生成StoreLoad指令吗？ synchronized是怎样逐步被优化的？","tags":["concurrent"],"categories":["并发"]},{"title":"20.水果成篮","path":"/2022/08/25/037.(Algo)水果成篮/","content":"904.Fruit into Baskets（Medium）题目描述你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 1： 123输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。 示例 2： 1234输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3： 1234输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4： 123输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示： 1 &lt;&#x3D; fruits.length &lt;&#x3D; 105 0 &lt;&#x3D; fruits[i] &lt; fruits.length 思路题目意思就是你有两个篮子，只能装2类水果，每一类水果数量不限。挨个走过一排水果树（fruits[i]）摘取果子。注意是连续摘取。这样就想到了互动窗口的思想，窗口内保持两种类型的水果，只要有第三种类型的水果进入，则缩小滑动窗口直到包含两类水果。难点在于怎么缩小窗口。采用HashMap(键唯一)，存储当前水果种类和数量(key和value)，初始化全为0，设置两个指针索引left和right，判断当前指针索引的水果的map值是否为零，是则最大数量count+1，然后在map中更新当前种类水果的value值；在count&gt;2时，即表示篮子不够用，需要移除水果，从起始位置种类水果开始移除，当前种类水果value-1，并且当此类水果的值为1时，最大数量count-1，并移动left，直到count&lt;=2；记录最大数量max，移动right重复上述过程，直至数组结尾。 代码实现1234567891011121314151617181920212223public int totalFruit(int[] fruits) &#123;\tint left=0,right=0,count=0,max=0; HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0;i&lt;fruits.length;i++)&#123; map.put(fruits[i],0); &#125; while(right&lt;fruits.length)&#123; //判断当前无此类水果，没有此类水果则种类+1 if(map.get(fruits[right])==0) count++; //采摘当前树上的水果 map.put(fruits[right],map.get(fruits[right])+1); while(count&gt;2)&#123;//水果种类&gt;2，即超过篮子数量 //从起始位置判断value值为1时，count-1，表示移除当前种类水果 if(map.get(fruits[left])==1) count--; //移除水果，更新当前水果种类的value值 map.put(fruits[left],map.get(fruits[left])-1); left++;//左移left &#125; max=Math.max(max,right-left+1); right++; &#125; return max;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","数组"],"categories":["LeetCode"]},{"title":"19.长度最小的子数组","path":"/2022/08/24/036.(Algo)长度最小的子数组/","content":"209.Minimum Size Subarray Sum（Medium）题目描述给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 12输入：target = 4, nums = [1,4,4]输出：1 示例 3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;&#x3D; target &lt;&#x3D; 109 1 &lt;&#x3D; nums.length &lt;&#x3D; 105 1 &lt;&#x3D; nums[i] &lt;&#x3D; 105 思路注意：题目求解的是连续子数组。 暴力求解：两个for循环，外层i做头，内层j=i做尾，开始累加找满足条件的和，然后更新subLength，和result比较，更新result。重复走完数组，得到满足条件的连续子数组。双层for循环，时间复杂度O(n^2^)，空间复杂度O(1) 双指针（滑动窗口思想）：使用两个索引的单层for循环来实现暴力求解中的两个for循环。具体思路是-循环右索引，累加数值直到&gt;=target，然后内层while循环更新result和sum，具体做法为sum减去left对应的值，之后向右移动left。单层for循环，时间复杂度O(n)，空间复杂度O(1)。 代码实现12345678910111213141516171819202122232425262728293031323334//暴力求解public int minSubArrayLen(int target, int[] nums) &#123;\tint result =Integer.MAX_VALUE;//初始化结果为最大值 int sum;//用于和找到目标值和 int subLength=0;//子数组长度 for(int i=0;i&lt;nums.length;i++)&#123; sum=0; for(int j =i;j&lt;nums.length;j++)&#123; sum+=nums[j]; if(sum&gt;=target)&#123; subLength=j-i+1; result=result&lt;subLength ? result:subLength; break; &#125; &#125; &#125; return result == Integer.MAX_VALUE ? 0:result;&#125;//双指针(滑动窗口思想)public int minSubArrayLen(int target, int[] nums) &#123;\tint result =Integer.MAX_VALUE;//初始化结果为最大值 int sum=0;//用于和找到目标值和 int left=0; for(int right=0;right&lt;nums.length;right++)&#123; sum+=nums[right]; //只要当前和&gt;=目标值，更新result，sum-nums[left]，left++ while(sum&gt;=target)&#123; result=Math.min(result,right-left+1); sum-=nums[left]; left++; &#125; &#125; return result == Integer.MAX_VALUE ? 0:result;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","数组"],"categories":["LeetCode"]},{"title":"18.有序数组的平方","path":"/2022/08/23/035.(Algo)有序数组的平方/","content":"977.Squares of a Sorted Array（Easy）题目描述给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 12输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;&#x3D; nums.length &lt;&#x3D; 104 -104 &lt;&#x3D; nums[i] &lt;&#x3D; 104 nums 已按 非递减顺序 排序 思路数组有序，负数平方后可能会变成最大值，所以最大值应该在数组两侧，用两个指针指向数组起始和结尾，平方后判断大值，写入新数组的末尾，依次判断完所有数值写入新数组即可。 代码实现123456789101112131415161718public int[] sortedSquares(int[] nums) &#123;\tint leftIndex=0,rightIndex=nums.length-1; int[] result=new int[nums.length]; int write=nums.length-1;//从数组末尾开始写入 while(leftIndex&lt;=rightIndex)&#123; if(nums[leftIndex]*nums[leftIndex]&gt; nums[rightIndex]*nums[rightIndex])&#123; result[write]=nums[leftIndex]*nums[leftIndex]; leftIndex++; write--; &#125;else&#123; result[write]=nums[rightIndex]*nums[rightIndex]; rightIndex--; write--; &#125;\t&#125;\treturn result;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","数组"],"categories":["LeetCode"]},{"title":"17.移动零","path":"/2022/08/23/034.(Algo)移动零/","content":"283.Move Zeroes（Easy）题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 12输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0] 示例 2: 12输入: nums = [0]输出: [0] 提示: 1 &lt;&#x3D; nums.length &lt;&#x3D; 104 -231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1 思路第一种：两个for循环，冒泡排序，将内层循环中判断条件改为复合题目的0即可。 第二种：增强for循环，重构数组，将0的位置全部覆盖，最后根据tem变量确定开始补0的位置，根据数组长度全部补0。 代码实现123456789101112131415161718192021222324252627//冒泡排序，将0置换到尾部，会存在冗余置换public void moveZeroes(int[] nums) &#123;\tint tem;\tfor(int i =0;i&lt;nums.length-1;i++)&#123; for(int j=0;j&lt;nums.length-1;j++)&#123; if(nums[j]==0)&#123; tem=nums[j]; nums[j]=nums[j+1]; nums[j+1]=tem; &#125; &#125; &#125;&#125;//重构数组，将0的位置全部覆盖，最后在数组尾部补0public void moveZeroes(int[] nums) &#123;\tint tem=0;\tfor(int val:nums)&#123; if(val!=0)&#123; nums[tem]=val; tem++; &#125;\t&#125; while(tem&lt;nums.length)&#123; nums[tem]=0; tem++; &#125;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","数组"],"categories":["LeetCode"]},{"title":"16.删除有序数组中的重复项","path":"/2022/08/19/033.(Algo)删除有序数组中的重复项/","content":"Remove Duplicates From Sorted-array（Easy）题目描述给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104 -104 &lt;&#x3D; nums[i] &lt;&#x3D; 104 nums 已按 升序 排列 思路双指针实现原地剔除重复元素。核心是在快慢指针对应元素值不同时，才会更新慢指针+1对应的元素为快指针对应的元素，并将慢指针向前进一位；一旦快慢指针对应元素值相等，则只更新快指针位置，直到两者对应值不相等，此时会将快指针对应的元素赋值给慢指针+1所对应的位置，然后慢指针前进一位。直到遍历完整个数组。 代码实现123456789101112public int removeDuplicates(int[] nums) &#123; int fastIndex=1; int slowIndex=0; while(fastIndex&lt;nums.length)&#123; if(nums[slowIndex]!=nums[fastIndex])&#123; nums[slowIndex+1]=nums[fastIndex]; slowIndex++; &#125; fastIndex++; &#125; return slowIndex+1;&#125; 来源： [力扣（LeetCode）](26. 删除有序数组中的重复项)","tags":["Algorithms","数组"],"categories":["LeetCode"]},{"title":"15.移除元素","path":"/2022/08/18/032.(Algo)移除元素/","content":"Remove Element（Easy）题目描述给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1： 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;&#x3D; nums.length &lt;&#x3D; 100 0 &lt;&#x3D; nums[i] &lt;&#x3D; 50 0 &lt;&#x3D; val &lt;&#x3D; 100 思路暴力破解采用双for循环，第一层用于查找目标元素，找到后用第二层移动元素，更改数组大小。时间复杂度：O(n^2)、空间复杂度：O(1)。 双指针同向双指针，一个快一个慢，通过快指针寻找目标值，慢指针将目标元素的后一位元素覆盖目标元素。用一个for循环，循环条件用于更新快指针，循环中判断快指针对应的值是否为目标元素，不是的话，将快指针对应的数组元素赋值给慢指针（同步），然后将慢指针向前进一位（slowIndex++），此时快慢指针异步；直到fastIndex对应的值等于目标值，会跳过if判断（此时不会更新slowIndex，导致下一轮快慢指针异步，为覆盖做准备）。时间复杂度：O(n)，空间复杂度：O(1) 代码实现123456789101112131415161718192021222324252627//暴力破解public int removeElement(int[] nums, int val) &#123; int size=nums.length; for(int i=0;i&lt;size;i++)&#123; if(nums[i]==val)&#123; for(int j=i+1;j&lt;size;j++)&#123; nums[j-1]=nums[j]; &#125; i--;//当前i对应值被i+1覆盖，i向前一位，方便下一轮i++ size--;//数组长度-1 &#125; &#125; return size;&#125;//双指针-同向，不会改变数组元素顺序public int removeElement(int[] nums, int val) &#123; int fastIndex=0; int slowIndex; for(slowIndex=0;fastIndex&lt;nums.length;fastIndex++)&#123; if(nums[fastIndex]!=val)&#123; nums[slowIndex]=nums[fastIndex]; slowIndex++; &#125; &#125; return slowIndex;&#125; 来源： [力扣（LeetCode）(https://leetcode.cn/problems/remove-element/)","tags":["Algorithms","数组"],"categories":["LeetCode"]},{"title":"14.在排序数组中查找元素的起始位置","path":"/2022/08/18/031.(Algo)在排序数组中查找元素的起始位置/","content":"34. Find First and Last Position of Element in Sorted Array（Medium）题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 12输入: nums = [1,3,5,6], target = 5输出: 2 示例 2: 12输入: nums = [1,3,5,6], target = 2输出: 1 示例 3: 12输入: nums = [1,3,5,6], target = 7输出: 4 提示: 1 &lt;&#x3D; nums.length &lt;&#x3D; 104 -104 &lt;&#x3D; nums[i] &lt;&#x3D; 104 nums 为 无重复元素 的 升序 排列数组 -104 &lt;&#x3D; target &lt;&#x3D; 104 思路暴力解法的时间复杂度是$O(n)$，尝试使用二分法查找。分别找区间的第一个和最后一个位置，即左边界和有边界。使用闭区间，while(left&lt;=right)这里的right是有意义的值。findLeft查找左边界，只有当 (mid==0||nums[mid-1]&lt;target) （即mid为数组第一个，或者mid-1对应的值小于目标值）和 nums[mid]==target （mid对应值为目标值）同时满足时，当前的mid即为左边界，否则返回-1 ； findRight查找右边界，只有当(mid==nums.length-1||nums[mid+1]&gt;target)（mid为数组最后一个，或者mid+1对应的值&gt;目标值）和 nums[mid]==target（mid对应值为目标值）同时满足时，当前的mid即为右边界。其他情况下，都是寻找区间，更新区间左右边界值。 代码实现12345678910111213141516171819202122232425262728293031323334353637public int[] searchRange(int[] nums, int target) &#123;\treturn new int[]&#123;findLeft(nums,target),findRight(nums,target)&#125;;&#125;private int findLeft(int[] nums,int target)&#123;\tint left =0,right=nums.length-1;\twhile(left&lt;=right)&#123; int mid=left+(right-left)/2; if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else if(nums[mid]&gt;target)&#123; right=mid-1; &#125;else if((mid==0||nums[mid-1]&lt;target)&amp;&amp;nums[mid]==target)&#123; return mid; else&#123;//nums[mid]==target 但不是最左边的一个，即不是左边界 right=mid-1; &#125;\t&#125; return -1;&#125;private int findRight(int[] nums,int target)&#123;\tint left =0,right=nums.length-1;\twhile(left&lt;=right)&#123; int mid =left+(right-left)/2; if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else if(nums[mid]&gt;target)&#123; right=mid-1; &#125;else if((mid==nums.length-1||nums[mid+1]&gt;target)&amp;&amp;nums[mid]==target)&#123; return mid; &#125;else&#123;//nums[mid]==target 但不是最右边的一个，即不是右边界 left=mid+1; &#125;\t&#125;\treturn -1;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms","数组"],"categories":["LeetCode"]},{"title":"13.搜索插入位置","path":"/2022/08/18/030.(Algo)搜索插入位置/","content":"35. Search Insert Position（Easy）题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 12输入: nums = [1,3,5,6], target = 5输出: 2 示例 2: 12输入: nums = [1,3,5,6], target = 2输出: 1 示例 3: 12输入: nums = [1,3,5,6], target = 7输出: 4 提示: 1 &lt;&#x3D; nums.length &lt;&#x3D; 104 -104 &lt;&#x3D; nums[i] &lt;&#x3D; 104 nums 为 无重复元素 的 升序 排列数组 -104 &lt;&#x3D; target &lt;&#x3D; 104 思路暴力解法的时间复杂度是$O(n)$，所以尝试使用二分查找法。对于二分查法而言，区间选择很重要。本题所求为目标值的下标，或者是未查询到目标值时返回目标值应当插入的位置下标。所以这里选择左闭右开区间，未查到时应插入的位置即为right。 代码实现1234567891011121314151617public int searchInsert(int[] nums, int target) &#123; int left=0; int right=nums.length; int mid; while(left&lt;right)&#123; mid =(right-left)/2+left; if(nums[mid]&gt;target)&#123; right=mid; &#125; else if(nums[mid]&lt;target)&#123; left=mid+1; &#125;else&#123; return mid; &#125; &#125; return right;&#125; 来源： 力扣（LeetCode） 代码随想录","tags":["Algorithms","数组"],"categories":["LeetCode"]},{"title":"12.二分查找","path":"/2022/08/18/029.(Algo)二分查找/","content":"704.Binary Search（Easy）题目描述给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 思路二分查找整体思路就是将待查数组一分为二，设定三个点：‘左中右’，将目标值与‘中’下标对应的值作比较，比目标值小，则将‘中’覆盖为‘左’，重新计算‘中’（(l+r)&#x2F;2）的值，反之则‘右’覆盖‘中’；关键点在于划分区间的闭合与否。基于此会有两种区间写法： 第一种：左闭右闭，即[left,right] while (left &lt;= right) 要使用 &lt;&#x3D; ，因为left == right是有意义的，所以使用 &lt;&#x3D; if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 第二种：左闭右开，即[left,right] while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle] 代码1234567891011121314151617public int search(int[] nums, int target) &#123;\tint left=0;\tint right=nums.length;//[left,right),左闭右开区间\tint mid;\twhile(left&lt;right)&#123; mid=(right-left)/2+left; if(nums[mid]&lt;target)&#123; left=mid+1; &#125; else if(nums[mid]&gt;target)&#123; right=mid;//当前值不可能是目标值，用mid直接赋值给right &#125; else&#123; return mid; &#125; &#125;\treturn -1;&#125; 来源： 力扣（LeetCode）","tags":["Algorithms"],"categories":["LeetCode"]},{"title":"CentOS7 配置Python3+selenium调用谷歌浏览器","path":"/2022/06/28/028.CentOS7 配置Python3+selenium调用谷歌浏览器健康填报/","content":"腾讯云服务器，系统CentOS7，Python自带2.7，版本过低。无法满足需求，本文记录下安装Python3和谷歌浏览器驱动，配合selenium实现体温填报系统自动填写。 安装谷歌浏览器和WebDriver 安装谷歌浏览器（google-chrome-stable）： curl https://intoli.com/install-google-chrome.sh | bash 注：本文全程使用root账户进行操作，普通用户是否可行不清楚。 测试是否安装成功 123456[root@VM-16-12-centos lighthouse]# google-chrome-stable --no-sandbox --headless --disable-gpu --screenshot https://www.baidu.com[0620/113820.501104:WARNING:bluez_dbus_manager.cc(248)] Floss manager not present, cannot set Floss enable/disable.[0620/113820.584207:WARNING:sandbox_linux.cc(376)] InitializeSandbox() called with multiple threads in process gpu-process.[0620/113821.294482:INFO:headless_shell.cc(660)] Written to file screenshot.png.[root@VM-16-12-centos lighthouse]# ll-rw------- 1 lighthouse lighthouse 20123 Jun 20 11:38 screenshot.png 查看目录确实下载了截图，证明安装成功，如上存在了screenshot.png文件 安装Chromedriver 3.1首先查看你安装的Chrome版本：google-chrome-stable --version 12[root@VM-16-12-centos lighthouse]# google-chrome-stable --versionGoogle Chrome 102.0.5005.115 我这里是102.0.5005.115，所以需要下载最接近的版本，这里提供镜像网站，找到你最接近的版本，邮件复制链接，输入命令: wget https://registry.npmmirror.com/-/binary/chromedriver/102.0.5005.27/chromedriver_linux64.zip 下载目标版本的linux64压缩包。 镜像地址： 国内镜像 https://npm.taobao.org/mirrors/chromedriver/ 官方地址：https://chromedriver.storage.googleapis.com 3.2 解压下载的文件：unzip chromedriver_linux64.zip 若提示bash: unzip : command not found 则需要安装unzip，使用命令：yum -y install unzip 解压完毕会多一个文件：chromedriver （这里是备用选项：给此文件增加权限 chmod a+x chromedriver） 3.3 安装：./chromedriver （找资料有说是放在&#x2F;usr&#x2F;bin&#x2F; 目录下，结合上一步的怎加权限，具体如何请多尝试下；增加权限后，使用selenium自动化任务，因为用到OCR识别，所以提示我tesseract没有路径，所以，增加权限这里应该是成功了。） 提示：ChromeDriver was started successfully. 此时Ctrl + C 退出安装即可。 安装Python3自带python2.7，版本太低了。 首先安装依赖，依次执行下面三条命令： 123yum -y groupinstall &quot;Development tools&quot;yum install -y ncurses-devel gdbm-devel xz-devel sqlite-devel tk-devel uuid-devel readline-devel bzip2-devel libffi-develyum install -y openssl-devel openssl11 openssl11-devel 下载安装包 12mkdir -p /doc/temp &amp;&amp; cd /doc/temp # 创建目录并进入该目录wget https://www.python.org/ftp/python/3.8.6/Python-3.8.6.tgz 编译 1234567891011# 1 设置编译FLAGexport CFLAGS=$(pkg-config --cflags openssl11)export LDFLAGS=$(pkg-config --libs openssl11)# 2 进入源码目录tar xvzf Python-3.8.6.tgzcd Python-3.8.6# 3 编译./configure --enable-optimizations &amp;&amp; make altinstall# 4 验证/usr/loctl/bin/Python3.8 --version/usr/loctl/bin/pip3.8 --version 1234567891011121314# 服务器操作主要过程（只保留用户输入命令和简短应答）[root@VM-16-12-centos temp]# export CFLAGS=$(pkg-config --cflags openssl11)[root@VM-16-12-centos temp]# export LDFLAGS=$(pkg-config --libs openssl11)[root@VM-16-12-centos temp]# echo $CFLAGS-I/usr/include/openssl11[root@VM-16-12-centos temp]# echo $LDFLAGS-L/usr/lib64/openssl11 -lssl -lcrypto[root@VM-16-12-centos temp]# tar xvzf Python-3.8.6.tgz[root@VM-16-12-centos temp]# cd Python-3.8.6/[root@VM-16-12-centos Python-3.8.6]# ./configure --enable-optimizations &amp;&amp; make altinstall[root@VM-16-12-centos Python-3.8.6]# /usr/local/bin/python3.8 --versionPython 3.8.6[root@VM-16-12-centos Python-3.8.6]# /usr/local/bin/pip3.8 --versionpip 20.2.1 from /usr/local/lib/python3.8/site-packages/pip (python 3.8) 配置 123# 配置快捷命令ln -sf /usr/local/bin/python3.8 /usr/bin/pythonln -sf /usr/local/bin/pip3.8 /usr/bin/pip （可选）配置pip源：vim ~/.pip/pip.conf 123456# 打开文件下填写以下内容[global]index-url = https://mirrors.aliyun.com/pypi/simple[install]trusted-host = mirrors.aliyun.com 验证python版本，可以看到软连接已指向python3.8 1234567[root@VM-16-12-centos lighthouse]# which python/usr/bin/python[root@VM-16-12-centos lighthouse]# cd /usr/bin/[root@VM-16-12-centos bin]# ll python*lrwxrwxrwx 1 root root 24 Jun 20 14:05 python -&gt; /usr/local/bin/python3.8lrwxrwxrwx 1 root root 9 Jan 19 2021 python2 -&gt; python2.7-rwxr-xr-x 1 root root 7144 Nov 17 2020 python2.7 以上谷歌浏览器和WebDriver还有Python3安装完毕。 下面是提问填报项目需要的包的安装即部署。 体温健康填报项目 项目所需依赖： pytesseract&#x3D;0.3.9 opencv-python&#x3D;4.5.5.62 numpy&#x3D;1.22.3 selenium&#x3D;3.141.0 pillow~&#x3D;9.1.1 依赖安装完毕，运行python代码，提示： selenium.common.exceptions.WebDriverException: Message: &#39;chromedriver&#39; executable needs to be in PATH. 在windows上是需要把chromedriver.exe文件放在python目录下的。这里我将chromedriver文件放在/usr/bin/目录下；然后提示： selenium.common.exceptions.WebDriverException: Message: &#39;chromedriver&#39; executable may have wrong permissions. 现在不知道怎么弄了。本篇先写到在这里，后面运行成功在写一篇。 项目用到了OCR识别，所以还需要安装tesseract，配合pytesseract使用。 ​ 参考资料： https://www.jianshu.com/p/34098b1a5ee1 http://t.zoukankan.com/xiao987334176-p-13729924.html https://www.bilibili.com/video/BV1AL4y1j7iR","tags":["Linux"],"categories":["指南"]},{"title":"linux虚拟机IP固定","path":"/2022/06/19/027.linux虚拟机固定IP/","content":"linux虚拟机IP固定 dhclient 命令：分配一个网络内可用的IP地址 ifconfig命令无法使用：缺乏net-tools 使用 sudo apt install net-tools 进行安装：提示E：无法定位软件包 net-tools 原因：本地没有该功能的资源或者更换了源但是没有重新updata 使用命令更新： sudo apt-get update ifconfig 命令 查看当前虚拟机IP地址：ens33—&gt;inet 192.168.70.130 通过命令：vim /etc/sysconfig/network-scripts/ifcfg-ens33 ubuntu安装vim：apt-get install vim 注：centOS中有，ubuntu系统中自 17.10 开始，已放弃在 &#x2F;etc&#x2F;network&#x2F;interfaces 里设置静态 IP 的办法了，即使配置也不会生效，而是改成 netplan 方式 ，配置写在 &#x2F;etc&#x2F;netplan&#x2F;01-network-manager-all.yaml 或者类似名称的 yaml 文件里（此处请注意 yaml 的语法格式） Ubuntu20配置值静态ip时需要修改&#x2F;etc&#x2F;netplan下面01-network-manager-all.yaml这个文件。 centOS： BOOTPROTO&#x3D;static ONBOOT&#x3D;yes 添加IPADDR&#x3D;192.168.xx.xx （此处为dhclient命令分配的IP地址） 添加NETMASK&#x3D;255.255.255.0 GATEWAY&#x3D;192.168.xx.xx DNS1&#x3D;119.29.29.29 之后使用命令systemctl restart network.service重启网络 ubuntu： 网络模式：NAT模式；进入&#x2F;etc&#x2F;netplan 目录，存在文件01-network-manager-all.yaml，打开发现文件只读无法更改，切换root用户sudo -s，使用命令nautilus以root身份打开文件管理器，找到目标文件，属性更改权限为读写模式。命令vim 01-network-manager-all.yaml进入配置文件编辑页面。 123456789101112131415# Let NetworkManager manage all devices on this systemnetwork: version: 2 renderer: NetworkManager ethernets: ens33: #配置的网卡名称 dhcp4: no #dhcp4关闭 冒号后有空格 dhcp6: no #dhcp6关闭 addresses: [192.168.70.130/24] #设置本机IP及掩码，注意掩码是24，有对应结果，不能瞎填，可通过网址：doc.m0n0.ch/quickstartpc、intro-CIDR.html查看 optional: true gateway4: 192.168.70.2 #设置网关 nameservers: addresses: [192.168.153.2, 114.114.114.114] #设置DNS# 注：根据你的NAT设置中的网关地址来设置，编辑-虚拟网络编辑器，选择你的网络模式，然后在窗口中间右边 NAT设置 之后使用命令netplan apply 或者 sudo netplan apply重启网卡即可。","tags":["Linux"],"categories":["Linux"]},{"title":"正则表达式简单用法","path":"/2022/06/05/026.正则表达式入门/","content":"正则表达式的简单用法，常用限定符、字符类和或运算。 常用限定符12示例：ac\tabc abbc\tabbbbc\tadc\tadddc ? ：前一个字符需出现0次或1次 ab?c –&gt;ac\tabc abbc\tabbbbc\tadc\tadddc *****：匹配0次或多次前一字符 ab*c–&gt;ac\tabc abbc\tabbbbc\tadc\tadddc **+**：匹配1次或多次前一个字符 ab+c–&gt;ac\tabc abbc\tabbbbc\tadc\tadddc **{4}**：匹配出现4次前字符 ab{4}c–&gt;ac\tabc abbc\tabbbbc\tadc\tadddc **{2,4}**：匹配出现2~4次前字符 ab{2,4}c–&gt;ac\tabc abbc\tabbbbc\tadc\tadddc 以上为单个字符的匹配，将根据限定符前面的单个字符进行匹配。那么多字符匹配呢？ (ab)+：将匹配1次或多次 ab 字符 (ab)+–&gt;ac\tabc ababc\tababababc\tadc\tadddc 或运算“OR”| ：竖杠表示或 a|b 则匹配 a 或者 b 12示例：a dog\ta cat\ta bird a (cat|dog)–&gt;a dog\ta cat\ta bird 上述匹配前两个，注：括号不能省，否则就是匹配 a cat 或者 dog 这两个，而不是 a cat 或a dog。 字符类[]用**[]**匹配括号类出现的字符 [abc]+–&gt;abc\taabc\tabbcsdab\t会匹配由abc三个字母组成的字符串（因为加了+，不加则是单个字符） ^ –&gt;反向 [^abc]+ –&gt;abc\taabc\tabbcsdab 只会匹配不包含abc字符的字符串 元字符数字字符：\\d 表示所有的数字字符，等同于**[0-9]** 单词字符：\\w 表示英文数字及下划线，大致等价于[a-zA-Z0-9]，但是无法匹配a_bb这类包含下划线的字符串 空白符：\\s 表示包含Tab和换行符 dws小写是包含，大写DWS则是不包含反义 任意字符（不包括换行符）：**.** ^：匹配行首 $：匹配行尾 贪婪匹配和懒惰匹配12示例&lt;span&gt;&lt;b&gt;This is a sample text&lt;/b&gt;&lt;/span&gt; 匹配包含 &lt;&gt; 的字符 &lt;.+&gt; –&gt; &lt; span &gt;&lt; b &gt;This is a sample text&lt; &#x2F;b &gt;&lt; &#x2F;span &gt; 上面的表达式会将所有的&lt;&gt;匹配为一个整体，即&lt; span&gt;&lt;………….&#x2F;span &gt; &lt;.+?&gt; 添加? 将贪婪匹配切换为懒惰匹配，则 &lt; span &gt; &lt; b &gt; This is a sample text &lt; &#x2F;b &gt; &lt; &#x2F;span &gt; 只会匹配最近&lt;&gt;对 示例 颜色匹配：以#开头，a-f，6位 则使用 #[a-fA-F0-9]{6}\\b #00 #ffffff #00hh00 #aabbcc #000000 #ffffffff","tags":["regex"],"categories":["正则表达式"]},{"title":"conda常用命令","path":"/2022/05/28/025.conda命令/","content":"深度学习中创建多个虚拟环境，以防各版本依赖之间的冲突。 这里记录下常用的 conda 命令，还有如何在当前虚拟环境中使用 jupyter 。 查看环境查看所有已创建的环境： conda env list查看在某一环境下所安装的包：conda list -n myenv查看当前环境下的所有第三方库：conda list 创建环境conda create -n env_name package_names 进入环境activate my_env 进入一个已创建的环境 离开环境deactivate 如需要更新包conda upgrade --all or conda update package_name 如需要安装包conda install package_name or conda install pandas numpy 卸载包conda remove package_names 在当前虚拟环境中使用jupyter notebook切换到你需要使用 Jupyter notebook 的虚拟环境；然后输入 conda install ipykernel 安装ipykernel库；之后输入 python -m ipykernel install --user --name &lt;当前环境名&gt; --display-name &lt;当前环境名&gt; 。 完毕，之后在当前环境输入 jupyter notebook 或者在vscode中创建 .ipynb 文件，都可以在本虚拟环境中使用 jupyter。 删除当前的kernel1 查看安装了哪些虚拟环境kernel（在base或虚拟环境下运行都可以）： jupyter kernelspec list 2 删除指定的kernel： jupyter kernelspec uninstall &lt;需要卸载环境名&gt;","tags":["Python"],"categories":["指南"]},{"title":"二叉堆之优先级队列的构建","path":"/2022/03/29/024.优先级队列（java）/","content":"优先级队列的构建二叉堆概念二叉堆（Binary Heap）逻辑上属于一棵完全二叉树，但是储存在数组中，用数组的索引作为指针。在逻辑上，就会有一个结点其索引为 k ,则它的父节点为 k/2 （整除），其左右孩子结点索引为 k*2 和 k*2+1 。作为一种数据结构，其操作主要有两个：数据的 sink (下沉) swim （上浮）两个操作，用以维护二叉堆的性质： 堆顶元素为最值，决定大小堆 父节点值大于等于其所有子节点二叉堆的主要应用有两个：排序方法‘堆排序’和数据结构‘优先级队列’ 优先级队列这种数据结构的特点是，在插入或者删除元素的时候，元素会自动排序满足二叉堆的性质。一种数据结构的功能就是增删改查，优先级队列主要是 insert 插入一个元素和 delMax删除最大元素（也可以是最小值，需要使用最小堆）。下面是代码，申请空间时多申请一个，数组索引0不用。主要的函数包括insert 插入， delMax 删除并返回最大元素， swim 上浮元素， sink 下沉元素。 Java代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Priority_Queue&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; //获取父节点的索引 int parent(int root) &#123; return root / 2; &#125; //获取左孩子的索引 int left(int root) &#123; return root * 2; &#125; //获取右孩子的索引 int right(int root) &#123; return root * 2 + 1; &#125; //存储元素的数组 private Key[] pq; //当前PriorityQueue中的元素个数 private int N = 0; public Priority_Queue(int cap) &#123; //索引0不用，所以多分配一个空间 pq = (Key[]) new Comparable[cap + 1]; &#125; //返回当前队列中最大的元素 public Key max() &#123; return pq[1]; &#125; //插入元素e public void insert(Key e) &#123; N++; pq[N] = e; swim(N); &#125; //删除并返回当前队列最大元素 public Key delMax() &#123; Key max = pq[1];//最大堆堆顶元素最大 exch(1, N);//把这个最大元素换到最后，删除 pq[N] = null; N--; sink(1);//让pq[1]下沉到正确位置 return max; &#125; //上浮第k个元素，以维护最大堆性质 private void swim(int k) &#123; //如果上浮到堆顶，就不能再上浮了 while (k &gt; 1 &amp;&amp; less(parent(k), k)) &#123; //如果第k个元素比上层大，将k换上去 exch(parent(k), k); k = parent(k); &#125; &#125; //下沉k个元素，以维护最大堆性质 private void sink(int k) &#123; //如果沉到堆底，就沉不下去了 while (left(k) &lt;= N) &#123; //先假设左边节点较大 int older = left(k); //如果右边节点存在，比一下大小 if (right(k) &lt;= N &amp;&amp; less(older, right(k))) older = right(k); //节点k比两孩子都大，则不必下沉 if (less(older, k)) break; //否则不符合大堆的结构，下沉k节点 exch(k, older); k = older; &#125; &#125; //交换数组的两个元素 private void exch(int i, int j) &#123; Key temp = pq[i]; pq[i] = pq[j]; pq[j] = temp; &#125; //pq[i]是否比pq[j]小？ private boolean less(int i, int j) &#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125;&#125; 来源： labuladong的算法小抄","tags":["数据结构"],"categories":["LeetCode"]},{"title":"11.合并两个有序链表","path":"/2022/03/27/023.(Algo)合并两个有序链表/","content":"21.Merge Two Sorted Lists（Easy）题目描述将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4] 示例 2： 输入：l1 &#x3D; [], l2 &#x3D; []输出：[] 示例 3： 输入：l1 &#x3D; [], l2 &#x3D; [0]输出：[0] 思路输入已经是升序链表，所以直接创建第三个链表 temp 存放输入两个链表的较小值，while循环比较两个链表值的大小，将小的值的节点连在temp上，更新链表指针，直到其中一个链表为空，然后判断剩下的链表是否为空，不为空则全部接到temp链表末尾。 代码实现12345678910111213141516171819202122class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode temp=new ListNode(); ListNode p=temp; ListNode p1=list1, p2=list2; while(p1!=null &amp;&amp; p2!=null)&#123; if(p1.val&gt;p2.val)&#123; p.next=p2; p2=p2.next; &#125;else&#123; p.next=p1; p1=p1.next; &#125; p=p.next; &#125; if(p1!=null) p.next=p1; if(p2!=null) p.next=p2; return temp.next; &#125;&#125; 复杂度分析 时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，list1 和 list2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。 空间复杂度：O(1)。我们只需要常数的空间存放若干变量。 来源： 力扣（LeetCode） labuladong的算法小抄","tags":["Algorithms","双指针"],"categories":["LeetCode"]},{"title":"9.二叉树的直径","path":"/2022/03/25/021.(Algo)二叉树的直径/","content":"543.Diameter of Binary Tree（Easy）题目描述给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 示例 :给定二叉树 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 思路二叉树的直径就是左右子树的最大深度之和。 求解子树问题，首先想到给函数设置返回值，在后序遍历位置进行求解。因为先序遍历是依次访问每个节点，求解子树最大深度就需要每个节点都遍历一遍，效率不高；采用后续遍历，不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。 具体代码如下： ​ 定义全局面量记录最大直径，然后后序遍历二叉树，计算当前节点的左右子树深度，比较更新全局最大深度。返回的值表示当前节点的子树的最大深度，再+1，则表示当前节点父节点的最大深度。 代码实现12345678910111213141516171819class Solution &#123; int maxDiameter=0;//全局变量，记录最大直径 public int diameterOfBinaryTree(TreeNode root) &#123; maxDepth(root); return maxDiameter; &#125; int maxDepth(TreeNode root)&#123; if(root==null) return 0; int leftMax=maxDepth(root.left); int rightMax=maxDepth(root.right); //在后序遍历位置进行计算和所求值的更新 //计算当前节点的最大直径 int myDiameter=leftMax+rightMax; //计算当前节点的直径和全局最大哪个大，更新全局最大 maxDiameter=Math.max(myDiameter,maxDiameter); return 1+Math.max(leftMax,rightMax); &#125;&#125; 来源： 力扣（LeetCode） labuladong的算法小抄","tags":["Algorithms","二叉树"],"categories":["LeetCode"]},{"title":"8.二叉树的最大深度","path":"/2022/03/24/020.(Algo)二叉树的最大深度/","content":"104. Maximum Depth of Binary Tree（Easy）题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \\9 20 / \\ 15 7 返回它的最大深度 3 。 思路求解一棵二叉树的最大深度，可以采用二叉树遍历实现，定义一个外部变量，记录每个节点所在的深度，比较大小则可以得到最大深度。 下面代码很容易理解，由root节点进入 traverse 方法，然后就判断当前节点是否是空节点（也即说明当前节点的父节点是叶子结点），若当前节点为空，则比较res和depth的大小，将结果赋予res，即为当前的最大深度；若不为空，则当前深度 depth++ ，然后遍历当前节点的左右子树，最后的 depth-- 表示当前节点的左右子树都遍历完毕，要返回当前节点的父节点了，所以深度会减一。 另解： 一棵二叉树的深度是指任意结点到根结点的距离；高度则是任意结点到叶子结点的距离。所以一课二叉树的最大深度=最大高度。可以采用后序遍历，求出子结点的高度，然后其父节点的高度就是当前节点+1。 代码实现1234567891011121314151617181920212223242526class Solution &#123; int res=0;//记录最大深度 int depth=0;//当前节点的深度 public int maxDepth(TreeNode root) &#123; traverse(root); return res; &#125; void traverse(TreeNode root)&#123; if(root==null)\treturn; depth++;//当前节点不为空，深度加一 if(root.left==null&amp;&amp;root.right==null)&#123; res=Math.max(res,depth); &#125; traverse(root.left); traverse(root.right); depth--;//当前节点左右子树都遍历完则深度减一，回到父节点深度 &#125;&#125;//法二:递归法 public int maxDepth(TreeNode root) &#123; if(root==null)\treturn 0; int leftmax=maxDepth(root.left); int rightmax=maxDepth(root.right); return 1+Math.max(leftmax,rightmax); &#125; 来源： 力扣（LeetCode） labuladong的算法小抄","tags":["Algorithms","二叉树"],"categories":["LeetCode"]},{"title":"10.二叉树的前序遍历","path":"/2022/03/24/022.(Algo)二叉树的前序遍历/","content":"144. Binary Tree Preorder Traversal（Easy）题目描述给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例1： 输入：root &#x3D; [1,null,2,3]输出：[1,2,3] 示例 2： 输入：root &#x3D; []输出：[] 示例 3： 输入：root &#x3D; [1]输出：[1] 思路创建一个列表集合，使用二叉树遍历框架，在前序位置编辑添加元素值的代码，执行即可。 上面是递归法。用迭代法也可以做。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; //递归法 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new LinkedList&lt;&gt;(); if(root==null) return res; res.add(root.val); res.addAll(preorderTraversal(root.left)); res.addAll(preorderTraversal(root.right)); return res; &#125; //迭代法 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result=new ArrayList&lt;&gt;(); if(root==null) return result; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node=stack.pop(); result.add(node.val); if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); &#125; return result; &#125; //统一迭代法：注意节点入栈的顺序，前序是右左中null，中序为右中null左，后序为中null右左 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) &#123; TreeNode node = st.peek(); if (node != null) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 &#125; &#125; return result; &#125;&#125; 来源： 力扣（LeetCode） labuladong的算法小抄","tags":["Algorithms","二叉树"],"categories":["LeetCode"]},{"title":"7.二叉搜索书中第K小的元素","path":"/2022/03/11/019.(Algo)二叉搜索书中第K小的元素/","content":"230. Kth Smallest Element in a BST（Medium）题目描述给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。 示例 1： 输入：root = [3,1,4,null,2], k = 1 输出：1 示例 2： 输入：root = [5,3,6,2,4,null,null,1], k = 3 输出：3 思路：首先看看二叉搜索树（二叉排序树）的定义： 二叉搜索树是一种节点值之间具有一定数量级次序的二叉树，对于树中每个节点： 若其左子树存在，则其左子树中每个节点的值都不大于该节点值； 若其右子树存在，则其右子树中每个节点的值都不小于该节点值。 所以对一棵二叉搜素树进行中序遍历，会得到一组从小到大有序排列的数，例如上图，经过中序遍历后，就会得到[0,1,2,3,5,6,7,8,9]有序数列，所以只需要在二叉树的中序遍历结构中增加比对代码即可，即按序判断遍历的当前元素的序列是否为目标值，是则找到第K小的元素。 代码实现：1234567891011121314151617181920class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; traverse(root,k); return res; &#125; int res=0;//定义结果 int rank=0;//定义当前元素的排名 void traverse(TreeNode root,int k)&#123; if(root==null) return; traverse(root.left,k); //中序遍历一课搜索二叉树，其结果是从小到大排列的 rank++; if(k==rank)&#123;//只需要比较当前元素的排名和目标值是否相等即可 res=root.val; return; &#125; traverse(root.right,k); &#125;&#125; 来源： 力扣（LeetCode） labuladong的算法小抄","tags":["Algorithms","二叉树"],"categories":["LeetCode"]},{"title":"6.从前序与中序遍历序列构造二叉树","path":"/2022/03/06/018.(Algo)从前序与中序遍历序列构造二叉树/","content":"105.Construct Binary Tree from Preorder and Inorder Traversal（Medium）题目描述给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例 1: 输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]输出: [3,9,20,null,null,15,7]示例 2: 输入: preorder &#x3D; [-1], inorder &#x3D; [-1]输出: [-1] 思路：前序遍历数组中，序列为0的元素即为根节点；而在中序遍历中，根节点将整个数组一分为二。所以利用这个特点，可以定位根节点在中序数组中的序列，然后将中序一分为二，接着在继续递归重复这种操作，找左右子树的根节点，和左右子树的子树的根节点。如此便可以构造一棵二叉树。 代码实现：下面是leetcode上可以测试通过的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return build(preorder,0,preorder.length-1, inorder,0,inorder.length-1); &#125; TreeNode build (int[] preorder,int preStart,int preEnd, int[] inorder,int inStart,int inEnd)&#123; if(preStart&gt;preEnd) return null; //root节点对应的值就是前序遍历数组的第一个元素 int rootVal=preorder[preStart]; //找到rootVal在中序遍历数组中的索引 int index=0; for(int i=inStart;i&lt;=inEnd;i++)&#123; if(inorder[i]==rootVal)&#123; index=i; break; &#125; &#125; int leftSize=index-inStart;//leftSize是中序数组中左子树的长度 TreeNode root =new TreeNode(rootVal);//构造出当前的根节点 //递归构造左右子树 root.left=build(preorder,preStart + 1,preStart + leftSize, inorder,inStart,index + 1); root.right=build(preorder,preStart + leftSize + 1,preEnd, inorder,index + 1,inEnd); return root; &#125;&#125; 再加一段本地idea自己编写测试示例的代码，可以在45和48两行中间插入输出语句实现二叉树的前中后三种遍历。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class _105 &#123; public static class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123; &#125; TreeNode(int val) &#123; this.val = val; &#125; TreeNode(int val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125; &#125;//二叉树节点定义 public static TreeNode buildTree(int[] preorder, int[] inorder) &#123; return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); &#125; static TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) &#123; if (preStart &gt; preEnd) return null; //root节点对应的值就是前序遍历数组的第一个元素 int rootVal = preorder[preStart]; //找到rootVal在中序遍历数组中的索引，并在中序数组中以根节点切分数组 int index = 0; for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == rootVal) &#123; index = i; break; &#125; &#125; int leftSize = index - inStart;//leftSize是中序数组中左子树的长度 TreeNode root = new TreeNode(rootVal);//构造出当前的根节点 //递归构造左右子树 // System.out.print(root.val+&quot;\\t&quot;);//输出前序续遍历节点的值 root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index + 1); // System.out.print(root.val+&quot;\\t&quot;);//输出中遍历节点的值 root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); // System.out.print(root.val+&quot;\\t&quot;);//输出后续遍历节点的值 return root; &#125; public static void main(String[] args) &#123; int[] preorder=&#123;3,9,20,15,7&#125;;//前序数组 int[] inorer=&#123;9,3,15,20,7&#125;;//中序数组 TreeNode treeNode = buildTree(preorder, inorer);//构造的整颗二叉树 &#125;&#125; 来源： 力扣（LeetCode） labuladong的算法小抄","tags":["Algorithms","二叉树"],"categories":["LeetCode"]},{"title":"JWT简单入门","path":"/2022/03/04/017.JWT简单入门/","content":"是什么？JSON Web Token，通过数字签名的方式，以JSON对象为载体，在不同的服务终端之间安全的传输信息。 什么用？JWT最常见的应用场景就是授权认证，一旦用户登录，后续每个请求都将包含JWT，系统在每次处理用户请求之前，都要先进行JWT安全校验，通过后才能进行请求处理。 组成JWT由三部分组成：Header、Payload、Signature。 Header：包含token名称，和编码信息 1234&#123; &#x27;typ&#x27;:&#x27;JWT&#x27;, &#x27;alg&#x27;:&#x27;HS256&#x27;&#125; Payload：载荷，存放有效信息，有三个：标准注册中的声明、公共申明、私有申明。就是信息安全分类。 12345&#123; &quot;sub&quot;:&quot;1234567890&quot;, &quot;name&quot;:&quot;john&quot;, &quot;admin&quot;:true&#125; Signature：签名 123var encodedString = base64UrlEncode(header) + &#x27;.&#x27;+ base64UrlEncode(payload);var signature = HMACSHA256(encodedString, &#x27;secret&#x27;); 代码部分生成JWT的过程123456789101112131415161718192021222324252627public class Test &#123; private long time=1000*60*60*24;//时间，一天 private String signature=&quot;admin&quot;; @org.junit.Test public void jwt()&#123; JwtBuilder jwtBuilder = Jwts.builder(); String jwtToken=jwtBuilder .setHeaderParam(&quot;typ&quot;,&quot;JWT&quot;) .setHeaderParam(&quot;alg&quot;,&quot;HS256&quot;)//上面两行为设置Header .claim(&quot;username&quot;,&quot;simen&quot;) .claim(&quot;role&quot;,&quot;admin&quot;) .setSubject(&quot;admin-test&quot;) .setExpiration(new Date(System.currentTimeMillis()+time)) .setId(UUID.randomUUID().toString())//以上设置payload信息 .signWith(SignatureAlgorithm.HS256,signature)//signature部分 .compact(); System.out.println(jwtToken);//输出则为生成的JWT &#125;&#125;//输出为：//eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9//.eyJ1c2VybmFtZSI6InNpbWVuIiwicm9sZSI6ImFkbWluIiwic3ViIjoiYWRtaW4tdGVzdCIsImV4cCI6MTY0NjQ3Njg0MywianRpIjoiOTM2NTg1NmEtZDI1Ny00MDU2LTk1ZjctODA1NmFkMTkwYjA1In0//.4HVYcdOQ-GTOwEDhIwSy0Yr37SofTOvSYZQ9q4FB0AQ 获取到JWT进行数据解密123456789101112@org.junit.Testpublic void parse()&#123; String token=&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 .eyJ1c2VybmFtZSI6InNpbWVuIiwicm9sZSI6ImFkbWluIiwic3ViIjoiYWRtaW4tdGVzdCIsImV4cCI6MTY0NjQ3Njg0MywianRpIjoiOTM2NTg1NmEtZDI1Ny00MDU2LTk1ZjctODA1NmFkMTkwYjA1In0 .4HVYcdOQ-GTOwEDhIwSy0Yr37SofTOvSYZQ9q4FB0AQ&quot;; JwtParser jwtParser = Jwts.parser(); Jws&lt;Claims&gt; claimsJws = jwtParser.setSigningKey(signature).parseClaimsJws(token); Claims claims = claimsJws.getBody(); System.out.println(claims.get(&quot;username&quot;));//获取username，并输出：simen&#125;","tags":["JWT"],"categories":["后端"]},{"title":"5.二叉树中的最大路径和","path":"/2022/02/28/016.(Algo)二叉树中的最大路径和/","content":"124. Binary Tree Maximum Path Sum(Hard)题目描述路径 被定义为一条从树中任意节点出发，沿 父节点-子节点 连接，达到 任意节点 的序列。同一个节点在一条路径序列中 至多 出现一次 。该路径 至少 包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例 1： 输入：root &#x3D; [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6示例 2： 输入：root &#x3D; [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42 提示： 树中节点数目范围是 [1, 3 * 104]-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000 思路：根据二叉树的遍历算法框架，如下代码，采用后序遍历算法，即找到最底层没有子节点的子树，然后计算当前没有子节点的子树的最大路径和，即左子树路径和（为0）+右子树路径和（为0）+当前子树自身的值，然后通过 res=Math.max(res,pathMaxSum) 计算更新单边最大路径和。重复递归。 1234567void traverse(TreeNode root)&#123; //前序遍历代码书写位置 traverse(root.left); //中序遍历代码书写位置 traverse(root.right); //后序遍历代码书写位置&#125; 举例： 一棵三个节点的二叉树，a(2) ← r(1) → b(3)，根节点为 r ，左子树为 a ，右子树为 b 。 首先根节点进入递归函数 oneSideMax(r) ，判断 r 不为空，进入下一句 leftMaxSum=Math.max(0,oneSideMax(r.left)) 通过 oneSideMax(r.left) 使 r 的左子树 a 进入递归 进入步骤1 ，判空，返回值为0 返回步骤2，判断 leftMaxSum=0 ，同步骤返回 rightMaxSum=0 计算 pathMaxSum=root.val + leftMaxSum + rightMaxSum ，即为2+0+0&#x3D;2 更新最大单边路径和： res=Math.max(res, pathMaxSum) ，即res=2 步骤2的 leftMaxSum=2 之后 rightMaxSum = Math.max(0, oneSideMax(root.right)) ，使 r 的右子树 b 进入递归 重复上述，计算得到 rightMaxSum=3 ，此时的 pathMaxSum=3 ，res=3 最终计算 pathMaxSum=1+2+3=6 ，res=max(3,6)=6 最好自己动手在纸上模拟程序巡行的步骤，做一个间的顺序模拟，结果就会很清楚。 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Java中定义的二叉树结构 * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int res = Integer.MIN_VALUE;//定义最小返回值 public int maxPathSum(TreeNode root) &#123; if(root==null) &#123;//判断根节点是否为空 return 0; &#125; oneSideMax(root);//递归计算单边路径和时，顺便计算最大路径和 return res; &#125; //定义方法：计算从根节点root为起点的最大单边路径和 int oneSideMax(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; //遍历左右子树 int leftMaxSum = Math.max(0, oneSideMax(root.left)); int rightMaxSum = Math.max(0, oneSideMax(root.right)); //后序遍历位置，顺便更新最大路径和 int pathMaxSum=root.val + leftMaxSum + rightMaxSum; res=Math.max(res, pathMaxSum); //左右子树的最大单边路径和加上根节点的值就是从根节点root为起点的最大单边路径和 return Math.max(leftMaxSum, rightMaxSum) + root.val; &#125;&#125; 复杂度分析： 时间复杂度：O(n) 用分治法解决二叉树问题的时间复杂度：O(二叉树节点个数 * 每个节点的计算时间) 举例：二叉树节点个数为 N，每个节点上的计算时间为 O(1)。总的时间复杂度为 O(N) 空间复杂度：O(n) 来源： 力扣（LeetCode） labuladong的算法小抄","tags":["Algorithms","二叉树"],"categories":["LeetCode"]},{"title":"Ajax简单入门","path":"/2022/01/21/015.ajax 简单入门/","content":"Ajax概念Ajax &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） 传统的 Web 网站，提交表单，需要重新加载整个页面 AJAX是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术，核心在于异步 AJAX是基于现有的Internet标准，并且联合使用它们： XMLHttpRequest 对象 (异步的与服务器交换数据) JavaScript&#x2F;DOM (信息显示&#x2F;交互) CSS (给数据定义样式) XML (作为转换数据的格式) 应用场景目前前后端分离技术，基本是 ajax 技术 前端展示的数据都是通过 ajax 请求服务器，然后服务器返回数据 例如 APP 页面的数据展示，网站数据的展示，小程序等等，基本涵盖所有的场景 代码1234567891011121314151617181920212223242526272829&lt;body&gt;\t&lt;div&gt; &lt;h1 id=&quot;here&quot;&gt;&lt;/h1&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery.min.js&quot;&gt;&lt;/script&gt;\t&lt;script&gt; console.log(&quot;start&quot;); $.ajax(&#123; type: &quot;get&quot;, //请求方式 url: &quot;服务器地址&quot;, data: &#123; &quot;name&quot;: &quot;ceshi&quot; &#125;, dataType: &quot;json&quot;,//数据类型 success: function(response)&#123; console.log(&quot;response&quot;); console.log(response); document.getElementById(&quot;here&quot;).innerHTML= respone.name;//将data中的name值取出来填入&lt;h1&gt;中 &#125; &#125;); console.log(&quot;end&quot;); //注：此处ajax不是原生，而是jQuery包装过的ajax，不会产生兼容性的问题\t&lt;/script&gt;&lt;/body&gt; 上面代码执行的时候，第一句 console.log(&quot;start&quot;);执行完毕，接着向下会发出 ajax 向服务器的请求数据，可能会产生时间延迟，但不会因此而阻塞后面的代码，即 console.log(&quot;end&quot;);正常执行。 运行代码，控制台先输出 start 接着输出 end 然后才会执行ajax的内容。","tags":["Ajax"],"categories":["前端"]},{"title":"斯坦福21秋季：实用机器学习--笔记4","path":"/2021/11/19/014.斯坦福21秋季：实用机器学习--笔记4/","content":"Feature Engineering特征工程Feature Engineering为什么需要特征工程： 因为机器学习的算法比较喜欢定义的比较好的、它能比较好的去处理的、固定长度的输入输出。 Machine learning algorithms prefer well defined fixed length input&#x2F;output Feature engineering(FE)is the key to ML models before deep learning(DL) In a computer vision task,people try various FE methods and then train a SVM model DL train deep neural networks to extract features Features are relevant to the task. IbObTO.png 手工标注和神经网络标注的对比。 Tabular Data Features Int&#x2F;float: directly use or or bin to $n$ unique int value实数集离散化，最大最小区间切成n个bin子区间，标注顺序。不在纠结数值。 Categorical data:one-hot encoding 独热编码 Map rare categories into”Unknown” IbO7m6.png 指定类别为1，其余为0。不重要的特征直接忽略。 Date-time: a feature list such as 时间编码 [year, month, day,day_of_year, week_of_year, day_of_week] Feature combination: Cartesian product of two feature groups 特征组进行组合 [cat, dog] x [male, female]-&gt; [(cat, male), (cat, female), (dog, male), (dog,female)] Text Feature Represent text as token features Bag of words(BoW) model Limitations: needs careful vocabulary design, missing context IbOoOx.png Word Embeddings(e.g. Word2vec): Vectorizing words such that similar words are placed close together Trained by predicting target word from context words Pre-trained language models (e.g. universal sentence encoder BERT, GPT-3) Giant transformer models Trained with large amount of unannotated data Usage: Text embedding; fine-tuning for downstream tasks IbOI61.png Image&#x2F;Video Features Traditionally extract images by hand-craft features such as SIFT Now pre-trained deep neural networks are common used as feature extractor ResNet: trained with ImageNet (image classification) I3D: trained with Kinetics (action classification) Many off-the-shelf models available IbOH0K.png Summary Features are representations of raw data that are relevant to the target task Feature engineering VS Feature learning The latter is preferred if available (images&#x2F;videos&#x2F;audio&#x2F;text) Will cover more later in “transfer learning” 特征工程很重要，但又没有固定的套路，还是需要看任务需求进行特征选取。 数据到模型中间还是有鸿沟。图片文本视频上用深度学习抽取特征已经成为了主流。","tags":["机器学习"],"categories":["MOOC"]},{"title":"斯坦福21秋季：实用机器学习--笔记3","path":"/2021/11/17/013.斯坦福21秋季：实用机器学习--笔记3/","content":"2.3 Data Transformation Data are transformed into forms apropriate for ML algorithms It could include most data preprocessing steps(e.g. data cleaning, feature engineering) We focus on methods in a particular step for various data types 123456graph LRA[Data data collecting] --&gt;B[Labelling &amp; cleaning]--&gt; C(Data Tranformation)--&gt; D[Feature engineering]--&gt; E[Medel training] Normalization for Real Value Columns对实数的常规化处理方式 Min-max normalization: linearly map to a new min a and max $x’_i&#x3D;$$\\frac {x_i-min_x} {man_x-min_x}(b-a)+a$ Z-score normalization:0 mean,1 standard deviation $x’_i&#x3D;$$\\frac {x_i-mean(x)} {std(x)}$ Decimal scaling小数定标标准化 $x’_i&#x3D;$$\\frac {x_i}{10^j}$ $smallest\\quad j\\quad s.t.\\quad max( Log scaling log函数转换 $x’_i&#x3D;\\log(x_i)$ 按比例缩小到较小的指定范围内，好处： 提升模型的收敛速度 提升模型的精度 Image Transformations图片转换 Our previous web scraping will scrape 15TB images for a year 5 millions houses sold in US per year,20images&#x2F;house, ~153KB per image,1041x732 resolution Down sampling and cropping Reduce image sizes to save storage and for fast loading ML is good at low-resolution images ~320x224 resolution –&gt; 1.4TB Be aware of(jpeg)image quality Medium(80%-90%)may –&gt;1% acc drop Image whitening Make input less redundant, Model converges faster VIdeo Transformations视频转换 Average video length Movies2h, You Tube videos ~11min, Tiktok short videos15sec Preprocessing to balance storage, quality and loading speed We often use short video clips(&lt;10sec) Each clip usually contains a single event(e.g. a human action) Decode a playable video, sample a sequence of frames Best for loading, but 10x more space Computation may be cheaper than storage(e.g. use GPU to decode) Can apply other image transformations to the frames Text Transformations文本转换 Stemming and lemmatization:a word →a common base form E.g. am, are, is →be car, cars, car’s, cars’-→car Tokenization: text -→a list of tokens(smallest unit to ML algorithms) By word: text. split(‘)· By char: text. split(“) By subwords: Unigram, WordPiece. e.g.”a new gpul!”-→”a,”new”,”gp”,”##u”,!” Summary Data transformation transfers data into formats preferred by ML algorithms,and balance data size,quality,and loading speed Tabular: normalize real value features Images: cropping, downsampling,whitening Videos: clipping,sampling frames Text: stemming,lemmatization,tokenization","tags":["机器学习"],"categories":["MOOC"]},{"title":"斯坦福21秋季：实用机器学习--笔记2","path":"/2021/11/09/012.斯坦福21秋季：使用机器学习--笔记2/","content":"2.2数据清理对收集的数据进行处理。因为数据收集的过程中会出现错误，或者缺失，所以在收集完数据后要进行一定的处理。 Types of Data Errors Outliers: data values that deviate from the distribution values in the column.样本某一特征值不在正常区间范围内导致的错误 Rule violations: violate integrity constraints such as “Not Null” and “Must be unique”.违反规则的数据，比如预测房价不能没有房价这个数据，或者是ID序列不唯一这种冲突 Pattern violations: violate syntactic and semantic constraints such as alignment, formatting,misspelling.模式错误，数据的格式、语义、拼写方面的错误。 Rule-based Detection基于规则的检测 Function dependencies: $x$-&gt;$y$ means a value $x$ determines a unique value $y$ . 基于映射关系的规则检测 E.g. zip code -state, EIN-&gt;company name.由邮政编码检测州属，纳税号检测公司名称 Denial constraints: a more flexible first-order logic formalism Phone number is not empty if vendor has an EIN If two captures of the same animal indicated by the same tag number , then the first one must be marked as original 指定一些灵活一阶规则判断。比如供应商有一个EIN，则电话号码不能为空；捕获的两张同一动物的ID相同，则第一次捕获的标记为原件。 Pattern-based Detection基于模式的检测 Syntactic patterns 语法模式 eng-&gt;English 进行转换 Map a column to the most prominent data type and identify values do not fit. 转换或丢弃 Semantic patterns 语义模式 Add rules through knowledge graph 知识图谱 Values in column “Country” need have capitals, so a value “Stanford” is invalid Summary Types of data errors: outliers,rule violations,pattern violations Detect errors and fix them by: model distribution, integrity constraints(functional dependencies, denial constraints), syntactic&#x2F;semantic patterns Multiple tool exist to help data cleaning Graphic interface for interactive cleaning Automatically detect and fix","tags":["机器学习"],"categories":["MOOC"]},{"title":"斯坦福21秋季：实用机器学习--笔记1","path":"/2021/11/08/011.斯坦福21秋季：实用机器学习--笔记1/","content":"B站up主跟李沐学AI，李沐的实用机器学习课程的笔记。边听边记录。 感兴趣的可以点击B站课程合集页面进行视频学习。 这里省略了第一章节数据来源的一些讲解笔记。 2.1 探索性数据分析Exploratory data analysis for house sales 12345678910111213141516导包import numpy as npimport pandas as pdimport matplotlib.pyplot as plt #借鉴MATLAB，画图import seaborn import sns #基于matplotlib，提供更多画法#读数据文本类数据采用压缩格式，存储读取会更好，下面是视频里面老师演示的数据集#data = pd.read_csv(&#x27;house_sales.zip&#x27;)#这里是在课程网站下载的数据集，把.csv格式格式的文件转存为.feather格式，再用read_feather读取，速度可以大大提升。数据集下载链接在文章底部data = pd.read_feather(&#x27;house_sales.ftr&#x27;)data.shape #查看样本，164944行，1789列#(164944,1789)data.head() #头属性 We drop columns that at least 30% values ate null to simplify our EDA. 12null_sum = data.isnull().sum() #计算空数据总和data.columns[null_sum &lt; len(data) * 0.3] #希望保留的数据 12#丢掉空值超过30%的数据，直接在源数据操作data.drop(columns = data.columns[null_sum &gt; len(data) * 0.3], inplace = True) We check the data types 12#查看数据类型，为后续样本类型转换准备data.dtypes Convert currency from string format such as $1,000,000 to float 1234567#价格数据的类型转换为浮点数currency = [&#x27;Sold price&#x27;, &#x27;Listed price&#x27;, &#x27;Tax assessed value&#x27;, &#x27;Annual tax amount&#x27;]for c in currency: data[c] = data[c].replace(r&#x27;[$,-]&#x27;, &#x27;&#x27;, regex = True).replace(r&#x27;^\\s*$&#x27;, np.nan, regex = True).astype(float)#采用正则表达式，将$ ， - 全部删除（-表示没有数据）#若是空字符串，转为np.nan#np.nan是一个float类型的数据 None是一个NoneType类型 Also convert areas feom string format such as 1000 sqft and 1 Acres to float as well 123456area = [&#x27;Total interior livable area&#x27;, &#x27;Lot size&#x27;]for c in areas: acres = data[c].str.contains(&#x27;Acres&#x27;) == True col = data[c].replace(r&#x27;\\b sqft\\b|\\b acres\\b|\\b, \\b&#x27;, &#x27;&#x27;,regex = True).astype(float) col[acres] *= 43560 #1 Acres = 43560 sqft data[c] = col Now we can check values of the numerical columns.You could see the min and max valus for several columns do not make sense. 12data.dexcribe() #查看数据描述，会展示当前数据集的count、mean、min、max等数据#可以大体看出数据噪音，为后续数据清理做准备 We filter out houses whose living areas are too small or too hard to simplify the visualiztion later. 123abnormal = (data[areas[1]] &lt; 10) | (data[areas[1]]&gt;1e4)data = data[~abnormal]sum(abnormal) Let’s check the histogram of the Sold Price , which is the target we want to predict. 1234ax = sns.histplot(np.log10(data[&#x27;Sold Price&#x27;]))ax.set_xlim([3,8])ax.set_xticks(range(3,9))ax.set_xticklabels([&#x27;%.0e&#x27;%a for a in 10**ax.get_xticks()]); A house has different types. Here are the top types: 1data[&#x27;Type&#x27;].value_counts()[0:20] #统计前20行属性的个数，查看噪音情况 Price density for different house types. 12types = data[&#x27;Type&#x27;].isin([&#x27;SingleFamily&#x27;, &#x27;Condo&#x27;, &#x27;MultiFamily&#x27;, &#x27;Townhouse&#x27;])sns.displot(pd.DateFrame(&#123;&#x27;Sold Price&#x27;:np.log10(data[types][&#x27;Sold Price&#x27;]),&#x27;Type&#x27;:data[types][&#x27;Type&#x27;]&#125;),x=&#x27;Sold Price&#x27;, hue=&#x27;Type&#x27;,kind=&#x27;kde&#x27;); Another important measurement is the sale price per living sqft.Let’s check the differences between different house types. 123data[&#x27;Price per living sqft&#x27;]=data[&#x27;Sold Price&#x27;]/data[&#x27;Total interior livable area&#x27;]#计算单位面积价格ax=sns.boxplot(x=&#x27;Type&#x27;,y=&#x27;Price per living#箱图 sqft&#x27;,data=data[types],fliersize=0)ax.set_ylim([0,2000])#y轴范围 注：箱图 箱图代表了什么 总之： 箱形图的优点有： 直观明了地识别数据批中的异常值 利用箱线图判断数据批的偏态和尾重 局限性 不能精确地衡量数据分布的偏态和尾重程度；对于批量比较大的数据，反映的信息更加模糊以及用中位数代表总体评价水平有一定的局限性 We know the location affect the price.Let’s check the price for the top 20 zip codes. 12345#从邮政编码来看房子位置的价格分布d=data[data[&#x27;Zip&#x27;].isin(data[&#x27;Zip&#x27;].value_counts()[:20].key())]ax=sns.boxplot(x=&#x27;Zip&#x27;,y=&#x27;Price per living sqft&#x27;,data=d,fliersize=0)#画箱图ax.set_ylim([0,2000])ax.set_xticklabels(ax.get_xticklabels(),rotation=90)#设置刻度，rotation为角度 Last，we visualize the correlation matrix of several columns. 123_,ax=plt.subplots(fiqsize=(6,6))columns=[&#x27;Sold Price&#x27;,&#x27;Listed Price&#x27;,&#x27;Annual tax amount&#x27;,&#x27;Price per living sqft&#x27;,&#x27;Elementary School Score&#x27;,&#x27;High School Score&#x27;]sns.heatmp(data[columns].corr(),annot=True,cmap=&#x27;RdY1Gn&#x27;,ax=ax) Summary This notebook demonstrates the basic technologies for EDA,including Understanding column data types,value,and distributions Understanding the ineractions between columns We only explored a small aspect of the data.You are welcome to dive deep into more details. 数据集下载链接： 官方地址：点击进入网站 –&gt;Dataset 下载速度慢可使用下列下载链接 百度云盘链接：https://pan.baidu.com/s/1qCbNWnLa8oXYCrPYAUXwHQ 提取码：av32 课程主页：https://c.d2l.ai/stanford-cs329p/","tags":["机器学习"],"categories":["MOOC"]},{"title":"考研一年回顾","path":"/2021/04/05/010.考研一年回顾/","content":"2020我再次考研​ 回顾2020。年中我终决定再次考研。 ​ 现在是2021年4月5日。如愿以偿，成功考上研究生，准备开启新的学习生活。想在这里得我这一年的经历做一个总结和回顾。 ​ 我的2020年考研生活过的比较充实，也感谢和我一起准备考研的哥们，感谢一路的陪伴。这条路是孤独的。谢谢我的坚持。 ​ 我在2020年初，是打算转行做Java后端开发的。上班过程中，自己也学一些相关的技能。年中疫情好转，我最终还是决定再次考研。完成我大四考研失败的夙愿。客观原因则是技术不太扎实，个人感觉还需要深入学习。由于本科不是计算机相关专业，也没有实际的开发经验，所以决定考研，利用读研时间，系统学习相关技能，找对自己感兴趣的方向。 2021重启新阶段​ 当初做这个Blog，是打算记录自己的学习过程，记录相关技术笔记。从初级到深入，一点一滴进步。知道决定考研，也就在没有更新过。 ​ 这次考研成功，也打算利用开学前的这段时间，将Java开发相关技术重新学习。在这里重新记录。再次立个flag，坚持输出，最少一月写一篇自己的学习心得、笔记相关。","tags":["读研"],"categories":["随想"]},{"title":"4.回文字符串","path":"/2020/05/14/009.(Algo)回文字符串/","content":"680. Valid Palindrome II (Easy)题目描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 思路：两数平方和等于目标值，且非负。取两个指针，将左指针初始为0，右指针初始则为sqrt(traget)。 代码实现：1234567891011121314151617181920212223242526public class _3反转字符串中的元音字母 &#123; //注意大写元音别漏掉了 private final static HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;( Arrays.asList(&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;)); public String reverseVowels(String s) &#123; if (s == null) &#123; return null; &#125; int i = 0, j = s.length() - 1; char[] result = new char[s.length()]; while (i &lt;= j) &#123; char ci = s.charAt(i); char cj = s.charAt(j); if (!vowels.contains(ci)) &#123; result[i++] = ci; &#125; else if (!vowels.contains(cj)) &#123; result[j--] = cj; &#125; else &#123; result[i++] = cj; result[j--] = ci; &#125; &#125; return new String(result); &#125;&#125; 复杂度分析： 时间复杂度：O(1) 空间复杂度：O(1) 来源： 力扣（LeetCode） GitHub 算法题项目Leetcode 题解 - 目录.md","tags":["Algorithms","双指针"],"categories":["LeetCode"]},{"title":"3.反转字符串中的元音字符","path":"/2020/05/14/008.(Algo)反转字符串中的元音字符/","content":"345. Reverse Vowels of a String (Easy)题目描述：编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello”输出: “holle” 示例 2: 输入: “leetcode”输出: “leotcede” 说明:元音字母不包含字母”y”。 思路：使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。 为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。 代码实现：1234567891011121314151617181920212223242526public class _3反转字符串中的元音字母 &#123; //注意大写元音别漏掉了 private final static HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;( Arrays.asList(&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;,&#x27;A&#x27;,&#x27;E&#x27;,&#x27;I&#x27;,&#x27;O&#x27;,&#x27;U&#x27;)); public String reverseVowels(String s) &#123; if (s == null) &#123; return null; &#125; int i = 0, j = s.length() - 1; char[] result = new char[s.length()]; while (i &lt;= j) &#123; char ci = s.charAt(i); char cj = s.charAt(j); if (!vowels.contains(ci)) &#123; result[i++] = ci; &#125; else if (!vowels.contains(cj)) &#123; result[j--] = cj; &#125; else &#123; result[i++] = cj; result[j--] = ci; &#125; &#125; return new String(result); &#125;&#125; 复杂度分析： 时间复杂度：O(1) 空间复杂度：O(1) 来源： 力扣（LeetCode） GitHub 算法题项目Leetcode 题解 - 目录.md","tags":["Algorithms","双指针"],"categories":["LeetCode"]},{"title":"2.两数平方和.md","path":"/2020/05/14/007.(Algo)两数平方和/","content":"633. Sum of Square Numbers (Easy)题目描述：给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 &#x3D; c。 示例1: 输入: 5输出: True解释: 1 * 1 + 2 * 2 &#x3D; 5 示例2: 输入: 3输出: False 思路：两数平方和等于目标值，且非负。取两个指针，将左指针初始为0，右指针初始则为sqrt(traget)。 代码实现：12345678910111213141516public class _2两数平方和 &#123; public boolean judgeSquareSum(int c) &#123; int a = 0, b = (int) Math.sqrt(c); while (a &lt;= b) &#123; int powSum = a * a + b * b; if (powSum == c) &#123; return true; &#125; else if (powSum &gt; c) &#123; b--; &#125; else &#123; a++; &#125; &#125; return false; &#125;&#125; 复杂度分析： 时间复杂度：O(1) 左指针为0，只需右指针即可找到traget，最多遍历一次0~sqrt(traget) 空间复杂度：O(1) 来源： 力扣（LeetCode） GitHub 算法题项目Leetcode 题解 - 目录.md","tags":["Algorithms","双指针"],"categories":["LeetCode"]},{"title":"vim插件indentline安装相关问题","path":"/2020/05/13/006.vim插件indentline安装相关问题/","content":"目录 插件的安装 遇到的问题 自己使用的vim配置文件 安装可以点击indentLine进入GitHub主页查看相关信息。 这里采用vim-Plug插件管理方式进行安装。 安装方式如下： 将下面代码写入 1Plug &#x27;yggdroot/indentline&#x27; 之后再vim中键入以下命令： :source %:PlugInstall安装完毕。 问题及解决方案安装完毕打开代码文件发现并没有显示缩进虚线。这个问题源于作者本人。在GitHub插件首页可以看到 This plugin is used for displaying thin vertical lines at eachindentation level for code indented with spaces. For code indented withtabs I think there is no need to support it, because you can use . 大意为使用tab缩进使该插件不起作用。 通过网络查找相关信息，给出下面解决方案： 在vimrc文件中添加下面的代码设置，将tab键缩进为4个空格。 12345set ts=4set expandtabset autoindentset listset lcs=tab:\\|\\ 个人配置个人配合主要是根据慕课网“玩转Vim 从放弃到爱不释手”免费课程学习总结而来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&quot;常用设置&quot;设置行号set number&quot;设置剪切板为默认set clipboard=unnamed&quot;背景主题设置set background=darkcolorscheme hybrid&quot;启动大小set lines=45 columns=100&quot;设置高亮syntax on&quot;按F2进入粘贴模式set pastetoggle=&lt;F2&gt;&quot;高亮搜索set hlsearch&quot;设置折叠方式&quot;set foldmethod=indent&quot;设置tab缩进为4个空格set ts=4set expandtabset autoindentset listset lcs=tab:\\|\\ &quot;一些方便的映射let mapleader=&#x27;,&#x27;let g:mapleader=&#x27;,&#x27;&quot;使用jj进入normal模式inoremap jj &lt;Esc&gt;`^&quot;使用leader+w直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;noremap &lt;leader&gt;w :w&lt;cr&gt;&quot;使用ctrl+h/j/k/l转换窗口noremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l&quot; Specify a directory for plugins&quot; - For Neovim: stdpath(&#x27;data&#x27;) . &#x27;/plugged&#x27;&quot; - Avoid using standard Vim directory names like &#x27;plugin&#x27;call plug#begin(&#x27;~/.vim/plugged&#x27;)&quot;开屏设置Plug &#x27;mhinz/vim-startify&#x27;Plug &#x27;vim-airline/vim-airline&#x27;Plug &#x27;vim-airline/vim-airline-themes&#x27;Plug &#x27;yggdroot/indentline&#x27;Plug &#x27;scrooloose/nerdtree&#x27;Plug &#x27;ctrlpvim/ctrlp.vim&#x27;&quot; Initialize plugin systemcall plug#end()&quot;nerdtree设置nnoremap &lt;leader&gt;v :NERDTreeFind&lt;cr&gt;nnoremap &lt;leader&gt;g :NERDTreeToggle&lt;cr&gt;&quot;模糊搜索设定let g:ctrlp_map = &#x27;&lt;c-p&gt;&#x27;","tags":["Vim"],"categories":["指南"]},{"title":"JDBC基础（二）","path":"/2020/05/11/005.JDBC基础（二）/","content":"JDBC（Java DataBase Connectivity）接上一篇，总结剩余的数据库连接技术知识。 JDBC控制事务 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 在这里使用事务是用于防止数据库操作中存在错误，SQL命令没有执行完毕，导致数据不完整。使用事务，则可以让多条SQL命令同时完成，或同事失败，保证数据在一次操作中的完整性。 操作： 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务：setAutoCommit（boolean autoCommit）：调用该方法设置参数为false，即开启事务 在执行SQL之前开启事务 提交事务：commit（） 当所有SQL执行完后提交事务 回滚事务：rollback（） 在catch中回滚事务 数据库连接池 概念：一个用来存放数据库连接的容器（集合）。当系统初始化后，容器被创建，在容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完毕后，会将连接对象归还给容器。 特点：节约资源，提高用户访问效率 实现： 标准接口：DataSource 方法：getConnect() 归还连接：在连接池中获取连接对象Connection，则使用Connection.close()方法归还连接（不会关闭） 第三方厂商提供： C3P0 Druid Druid：数据连接池的使用 步骤： 导入jar包 定义配置文件（.properties，名称任意，可放于任意目录下。需手动添加） 加载配置文件，Properties 获取数据库连接池对象：通过工厂来获取 DruidDataSourceFactory 获取连接：getConnection 简单演示 123456789101112131415161718 /**druid 演示 * @author */public class druidDemo1 &#123; public static void main(String[] args) throws Exception &#123; //1.导入jar包 //2.定义配置文件 //3.加载配置文件 Properties pro = new Properties(); InputStream is = druidDemo1.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource((Map) pro); //5.获取连接 Connection conn = ds.getConnection(); System.out.println(conn); &#125; &#125; 定义工具类 定义一个类 JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/**创建Druid连接池的工具类 * @author lhy */public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException&#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; close(null,stmt,conn); &#125; public static void close(ResultSet rs,Statement stmt, Connection conn)&#123; if (rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; 1234567891011121314151617181920212223242526272829303132/**工具类使用 * @author lhy */public class druidDemo2 &#123; public static void main(String[] args) &#123; /** * 完成添加操作，为test数据库中emp表添加一条记录 */ Connection conn=null; PreparedStatement pstmt =null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //2.定义sql String sql=&quot;insert into account values ( null , ?, ? )&quot;; //3.获取preparedStatement对象 pstmt = conn.prepareStatement(sql); //4.给？赋值 pstmt.setString(1,&quot;zhangsan&quot;); pstmt.setString(2,&quot;25&quot;); //pstmt.setString(3,&quot;12&quot;); //5.执行sql int count = pstmt.executeUpdate(); System.out.println(count); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //6.释放资源 JDBCUtils.close(pstmt,conn); &#125; &#125;&#125; Spring JDBC：JDBC Template 概念：spring框架对JDBC的简单封装。提供一个JDBCTemplate对象简化JDBC的开发。 步骤： 导入jar包 创建JdbcTemplate对象（依赖于数据源DataSource） JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CURD操作 update()：执行DML语句。增删改语句 queryForMap()：查询结果将结集封装为map集合，列名为key，值为value。 注意：查询结果集长度还能是1，即查询一条记录 queryForList()：查询结果集，将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query()：查询结果，将结果集封装为JavaBean对象 参数一般为RowMapper，使用eanPropertyRowMapper实现类，完成数据到JavaBean的自动封装。new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 一般用于聚合函数的查询 简单示例： 123456789101112131415/** * JdbcTemplate入门 */public class JdbcTemplateDemo1 &#123; public static void main(String[] args) &#123; //1.导入jar包 //2.创建JDBCTemplate对象 JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); //3.调用方法 String sql= &quot;update account set age = 21 where id =?&quot;; int count = template.update(sql, 1); System.out.println(count); &#125;&#125; 练习： 需求： 修改1号数据的job_id为120 添加一条记录 删除刚才添加的记录 查询所有id为1的记录，将其封装为Map集合 查询所有记录，将其封装为List 查询所有记录，将其封装为Emp对象的List集合 查询总记录数 表单如图所示，包含id，ename，job_id，joindate xxxxxxxxxx70 1public class jdbcDemo10 {2 public static void main(String[] args) {3 &#x2F;&#x2F;1.键盘录入，接受用户名和密码4 Scanner sc &#x3D; new Scanner(System.in);5 System.out.println(“请输入用户名：”);6 String username &#x3D; sc.nextLine();7 System.out.println(“请输入密码：”);8 String password &#x3D; sc.nextLine();9 &#x2F;&#x2F;2.调用方法10 boolean flag &#x3D; new jdbcDemo10().login(username, password);11 &#x2F;&#x2F;3.判断结果，输出不同语句12 if(flag){13 &#x2F;&#x2F;登录成功14 System.out.println(“登录成功！”);15 }else{16 System.out.println(“用户名或密码错误！”);17 }18 }19 20 &#x2F;**21 * 登录方法22 *&#x2F;23 public boolean login(String username,String password) {24 if (username &#x3D;&#x3D; null || password &#x3D;&#x3D; null) {25 return false;26 }27 Connection conn &#x3D; null;28 Statement stmt &#x3D; null;29 ResultSet rs &#x3D; null;30 try {31 conn &#x3D; JDBCUtils.getConnection();32 33 &#x2F;&#x2F;sql拼接会产生SQL注入问题，比如密码输入 a’ or ‘a’ &#x3D; ‘a34 String sql &#x3D; “select * from user where username &#x3D; ‘“ + username + “‘ and password &#x3D; ‘“ + password +”‘“;35 stmt &#x3D; conn.createStatement();36 rs &#x3D; stmt.executeQuery(sql);37 return rs.next();38 } catch (SQLException e) {39 e.printStackTrace();40 } finally {41 JDBCUtils.close(rs, stmt, conn);42 }43​44 return false;45 }46}47&#x2F;&#x2F;——————————————————48 public boolean login2(String username,String password) {49 if (username &#x3D;&#x3D; null || password &#x3D;&#x3D; null) {50 return false;51 }52 Connection conn &#x3D; null;53 Statement stmt &#x3D; null;54 ResultSet rs &#x3D; null;55 try {56 conn &#x3D; JDBCUtils.getConnection();57 String sql &#x3D; “select * from user where username &#x3D; ? and password &#x3D; ?;58 pstmt &#x3D; conn.prepareStatement(sql);59 pstmt.setString(1,username);60 pstmt.setString(2,password);61 rs &#x3D; pstmt.executeQuery();62 return rs.next();63 } catch (SQLException e) {64 e.printStackTrace();65 } finally {66 JDBCUtils.close(rs, pstmt, conn);67 }68 return false;69 }70}java 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class JdbcTemplateDemo2 &#123; //1.获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); //修改1号数据的job_id为120 @Test public void test1() &#123; //2.定义SQL语句 String sql = &quot;update emp set job_id = 100 where id = 1&quot;; //3.执行SQL int count = template.update(sql); //打印看执行是否成功 System.out.println(count); &#125; //添加一条记录 @Test public void test2() &#123; String sql = &quot;insert into emp(id,ename,job_id) values (?,?,?)&quot;; int count = template.update(sql, 3, &quot;wangmazi&quot;, 101); System.out.println(count); &#125; //删除刚才添加的记录 @Test public void test3() &#123; String sql = &quot;delete from emp where id=?&quot;; int count = template.update(sql, 3); System.out.println(count); &#125; //查询所有id为1的记录，将其封装为Map集合 @Test public void test4() &#123; String sql = &quot;select * from emp where id = ?&quot;; Map&lt;String,Object&gt; map = template.queryForMap(sql, 1); System.out.println(map); &#125; //查询所有记录，将其封装为List @Test public void test5() &#123; String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); System.out.println(list); &#125; //查询所有记录，将其封装为Emp对象的List集合 @Test public void test6() &#123; String sql = &quot;select * from emp &quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp:list) &#123; System.out.println(emp); &#125; &#125; //查询总记录数 @Test public void test7() &#123; String sql = &quot;select count(id) from emp&quot;; Long count = template.queryForObject(sql, long.class); System.out.println(count); &#125;&#125;","tags":["MySQL"],"categories":["后端"]},{"title":"JDBC基础（一）","path":"/2020/05/10/004.JDBC基础（一）/","content":"JDBC（Java DataBase Connectivity）概念Java数据库连接，定义了Java语言操作所有关系型数据库的规则，即接口。 IU4qKS.png 快速入门123456789101112131415161718192021\tpublic class jdbcDemo1 &#123; public static void main(String[] args) throws Exception &#123; //1. 导入驱动jar包 //2. 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3. 获取数据库连接对象Connec Connection conn = DriverManager.getConnection( &quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;root&quot;); //4. 定义SQL String sql = &quot;update login set password = 110 where id =1&quot;; //5. 获取执行SQL语句的对象Statement Statement stmt = conn.createStatement(); //6. 执行SQL，接收返回结果 int count = stmt.executeUpdate(sql); //7. 处理结果 System.out.println(count); // 8. 释放资源 stmt.close(); conn.close(); &#125;&#125; 详解各个对象DriverManager：驱动管理对象 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver)：注册与给定的驱动程序DriverManager 写代码则使用：Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 查看源码可知：在com.mysql.jdbc.Driver类中存在静态代码块 1234567static&#123; try&#123; java.sql.DriverManager.registerDriver(new Driver()); &#125;catch(SQLException)&#123; throw new RuntimeException(&quot;Can`t register driver!&quot;); &#125;&#125; 注意：mysql之后的驱动jar包可以省略注册驱动的步骤。 获取数据可连接： 方法： 1static Connection conn = DriverManager.getConnection(String url,String user, String password); 参数： url：指定连接的路径 语法：jdbc:mysql://IP地址（域名）:3306/数据库名称 细节：如果连接的是本机mysql服务器，并且默认端口是3306， ​ URL可以简写为：jdbc:mysql:///数据库名称（注意 ///） suer：用户名 password：密码 Connection：数据库连接对象 功能： 获取执行sql的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理实务： 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法石质参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行SQL的对象 执行sql boolean execute(String sql)：可以执行任意的sql int executeUpdate(String sql)：执行DML（insert、update、delete）语句、DDL（create、alter、drop）语句 -返回值：影响的行数（可以通过返回值判断是否执行成功）。 ResultSet executeQuery(String sql)：执行DQL（select）语句 举例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * jdbc练习 insert */public class jdbcDemo2 &#123; public static void main(String[] args) &#123; //为stmt和conn创建全局变量,使得在finally&#123;&#125;中可以正常释放资源 Statement stmt = null; Connection conn = null; try &#123; //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.定义sql //在login表中按主键（id）序号顺序添加一条记录 String sql = &quot;insert into login values(null,&#x27;zhangsna&#x27;,&#x27;110&#x27;)&quot;; /* //将login表中id=3的password更改为119 String sql = &quot;update login set password = 119 where id = 3&quot;; //2.定义sql,将login表中id=3记录删除 String sql = &quot;delete from login where id = 3&quot;; */ //3.获取Connection对象 conn = DriverManager.getConnection( &quot;jdbc:mysql:///test&quot;, &quot;root&quot;, &quot;root&quot; ); //4.获取执行SQL的对象 Statement stmt = conn.createStatement(); //5.执行sql，返回影响的行数 int count = stmt.executeUpdate(sql); //6.处理结果 System.out.println(count); if (count &gt; 0) &#123; System.out.println(&quot;添加成功！&quot;); &#125; else &#123; System.out.println(&quot;添加失败！&quot;); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 //避免空指针异常 if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; ResultSet：结果集对象 next()：游标向下移动一行，判断当前行是否是最后一行末尾（是否有数据），如果是，则返回false，否则返回true。 getXXX：获取数据 XXX：代表数据类型\t比如int：getInt() 参数： int：代表列的编号，从1开始。 String：代表列的名称。 实例： 简单使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class jdbcDemo6 &#123; public static void main(String[] args) &#123; //为stmt和conn创建全局变量,使得在finally&#123;&#125;中可以正常释放资源 Statement stmt = null; Connection conn = null; ResultSet rs = null; try &#123; //1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.定义sql,将login表中id=3记录删除 String sql = &quot;select * from login&quot;; //3.获取Connection对象 conn = DriverManager.getConnection( &quot;jdbc:mysql:///test&quot;, &quot;root&quot;, &quot;root&quot; ); //4.获取执行SQL的对象 Statement stmt = conn.createStatement(); //5.执行sql，返回影响的行数 rs = stmt.executeQuery(sql); //6.处理结果 //6.1让游标向下移动一行 rs.next(); //6.2获取数据 int id = rs.getInt(1); String username = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); //打印结果：1---zhangsan---110 System.out.println(id + &quot;---&quot; + username + &quot;---&quot; + password); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //7.释放资源 //避免空指针异常 if (stmt != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 遍历（游标向下一行—&gt;判断是否有数据—&gt;获取数据） 12345678910//6.处理结果//循环判断游标是否是最后一行末尾while(rs.next())&#123; //6.1获取数据 int id = rs.getInt(1); String username = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); //打印结果：1---zhangsan---110 System.out.println(id + &quot;---&quot; + username + &quot;---&quot; + password);&#125; 练习 定义一个方法，查询emp员工表的数据，将其封装为对象，然后装载集合，返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051** * @author 封装Emp表数据的JavaBean */public class emp &#123; private int id; private String ename; private int job_id; private Date joindate; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public int getJob_id() &#123; return job_id; &#125; public void setJob_id(int job_id) &#123; this.job_id = job_id; &#125; public Date getJoindate() &#123; return joindate; &#125; public void setJoindate(Date joindate) &#123; this.joindate = joindate; &#125; @Override public String toString() &#123; return &quot;emp&#123;&quot; + &quot;id=&quot; + id + &quot;, ename=&#x27;&quot; + ename + &#x27;\\&#x27;&#x27; + &quot;, job_id=&quot; + job_id + &quot;, joindate=&quot; + joindate + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*** 定义一个方法，查询emp员工表的数据，将其封装为对象，然后装载集合，返回。*/public class jdbcDemo9 &#123;\tpublic static void main(String[] args) &#123; List&lt;Emp&gt; list = new jdbcDemo9().findAll(); //打印List， //[emp&#123;id=1, ename=&#x27;zhangsan&#x27;, job_id=10, joindate=2015-02-01&#125;, //emp&#123;id=2, ename=&#x27;lisi&#x27;, job_id=11, joindate=2015-02-10&#125;] System.out.println(list);\t&#125;\tpublic List&lt;Emp&gt; findAll()&#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; List&lt;Emp&gt; list= null; try &#123; //1.注册驱动 //2.获取Connection对象 conn=JDBCUtils.getConnection(); //3.定义sql,将login表中id=3记录删除 String sql = &quot;select * from emp&quot;; //4.获取执行SQL的对象 Statement stmt = conn.createStatement(); //5.执行sql，返回影响的行数 rs = stmt.executeQuery(sql); //6.遍历结果集，封装对象，装载集合 Emp emp=null; list=new ArrayList&lt;Emp&gt;(); while(rs.next())&#123; //6.1获取数据 int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); //创建emp对象,并赋值 emp =new Emp(); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setJoindate(joindate); list.add(emp); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); JDBCUtils.close(rs,stmt,conn); &#125; return list;\t&#125;&#125; PreparedStatement：执行SQL的对象（比Statement功能强大） SQL注入问题：在拼接SQL时，有一些特殊关键字参与字符串的拼接。造成安全问题。 输入用户名随意，密码输入：a’ or ‘a’ &#x3D; ‘a sql：select * from user where username &#x3D; ‘fhdsjkf’ and password &#x3D; ‘a’ or ‘a’ &#x3D; ‘a’ 解决：使用PreparedStatemeent对象 预编译的SQL：参数使用？作为占位符 步骤 导入驱动jar包 注册驱动 获取数据库连接对象Connection 定义SQL：使用?作为占位符 如：select * from user where username = ？ 获取执行SQL语句的对象PreparedStatement 如：Connection.prepareStatement(String sql) 给？赋值 方法：对象.setXXX(参数1，参数2) 参数1：？的位置编号，从1开始；参数2：？的值 执行SQL，接收返回结果 处理结果 释放资源 12345678//......省略.....//定义sql语句String sql = &quot;select * from user where username = ？&quot;;//获取执行sql的对象pstmt = conn.prepareStatement(sql);//给？赋值pstmt.setString(1,username); 抽取JDBC工具类：JDBCUtils 目的：简化书写 分析： 抽取注册驱动 抽取一个方法，获取连接对象 抽取一个方法，释放资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需读一次即可拿到这些值。使用静态代码块 */ static &#123; try &#123; //读取资源文件，获取值 //1.创建Properties集合类 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader类加载器 ClassLoader classLoader=JDBCUtils.class.getClassLoader(); URL res=classLoader.getResource(&quot;jdbc.properties&quot;); String path=res.getPath(); //2.加载文件 pro.load(new FileReader(path)); //3.获取数据，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password= pro.getProperty(&quot;password&quot;); driver= pro.getProperty(&quot;driver&quot;); //4.注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url,user,password); &#125; /** * 释放资源 * * @param stmt * @param conn */ public static void close(Statement stmt, Connection conn) &#123; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(ResultSet rs, Statement stmt, Connection conn) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; if (stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 登录实例（不安全SQL拼接） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class jdbcDemo10 &#123; public static void main(String[] args) &#123; //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); //2.调用方法 boolean flag = new jdbcDemo10().login(username, password); //3.判断结果，输出不同语句 if(flag)&#123; //登录成功 System.out.println(&quot;登录成功！&quot;); &#125;else&#123; System.out.println(&quot;用户名或密码错误！&quot;); &#125; &#125; /** * 登录方法 */ public boolean login(String username,String password) &#123; if (username == null || password == null) &#123; return false; &#125; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); //sql拼接会产生SQL注入问题，比如密码输入 a&#x27; or &#x27;a&#x27; = &#x27;a String sql = &quot;select * from user where username = &#x27;&quot; + username + &quot;&#x27; and password = &#x27;&quot; + password +&quot;&#x27;&quot;; stmt = conn.createStatement(); rs = stmt.executeQuery(sql); return rs.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(rs, stmt, conn); &#125; return false; &#125;&#125;//—————————————————— public boolean login2(String username,String password) &#123; if (username == null || password == null) &#123; return false; &#125; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); String sql = &quot;select * from user where username = ? and password = ?; pstmt = conn.prepareStatement(sql); pstmt.setString(1,username); pstmt.setString(2,password); rs = pstmt.executeQuery(); return rs.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(rs, pstmt, conn); &#125; return false; &#125;&#125;","tags":["MySQL"],"categories":["后端"]},{"title":"Aja&Json","path":"/2020/05/09/003.Ajax&Json/","content":"Ajax 概念：asynchronous JavaScript and XML，异步的JavaScript和XML。是一种无需重新加载整个网页的情况下，能够更新部分网页的技术。提升用户体验。 实现方式： 原生的JS实现方法 Jqeury实现方式 $.ajax() 语法：$.ajax({键值对})； 12345678910111213$.ajax(&#123; url:&quot;ajaxServlet&quot;, //请求路径 type:&quot;POST&quot;, //请求方式，不写默认为GET data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, //请求参数（这里是json格式） //data:&quot;username=jack&amp;age=23&quot; success:function(data)&#123; alter(data); &#125;, //响应成功后的回调函数 error:function()&#123; alter(&quot;出错了。。。&quot;)； &#125;, //响应出现错误时的回调函数 dataType:&quot;text&quot; //设置接收到的响应数据的格式&#125;); $.get()：发送GET请求 123456- 语法：$.get(url, [data], [callback], [type]) - 参数：url： - 请求路径 - data：请求参数 - callback：回调函数 - type：响应结果的类型 $.post()：发送POST请求 123456789$.post( &quot;ajaxServlet&quot;,&#123;username:&quot;rose&quot;&#125;,\tfunction(data)&#123; alter(date) &#125;, &quot;text&quot;) Json 概念：JavaScript Object Notation，JavaScript对象表示法 java： 1234Person p = new Person();p.setName(&quot;jack&quot;);p.setAge(23);p.setGender(&quot;male&quot;); JavaScript : 1var p =&#123;&quot;name&quot;:&quot;jack&quot;, &quot;age&quot;:23, &quot;gender&quot;: &quot;male&quot;&#125;; Json现在多用于存储和交换文本信息。类似XML。但比XML更小、更快、更易解析。 语法： 基本规则 数据在名称&#x2F;值对中：Json数据由键值对构成 值取得类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在中括号中） {“persons”:[{},{}]} 对象（在大括号中） {“address”: {“province”: “陕西”…}} null 数据由逗号分隔：多个键值对用逗号隔开 大括号保存对象：使用{}定义Json格式 中括号保存数组：[] 12345678910111213141516//1.定义基本格式var person = &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:23, &quot;gender&quot;:true&#125;;//2.嵌套格式 &#123;&#125;→[]var persons = &#123; &quot;persons&quot;:[ &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:23, &quot;gender&quot;:true&#125;, &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:24, &quot;gender&quot;:true&#125;, &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:25, &quot;gender&quot;:true&#125; ]&#125;;//嵌套格式 []→&#123;&#125;var ps = [ &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:23, &quot;gender&quot;:true&#125;, &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:24, &quot;gender&quot;:true&#125;, &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:25, &quot;gender&quot;:true&#125;]; 获取数据 Json对象.键名 1var name = person.name; Json对象[“键名”] 1var name = person[&quot;name&quot;]; 数组对象[索引] 12var name = persons.persons[2].name; //嵌套格式 &#123;&#125;→[]var name = ps[1].name; //嵌套格式 []→&#123;&#125; 遍历 1234567891011//获取person对象中的所有键和值for(var key in person)&#123; alter(key)&#125;//获取ps中的所有值for(var i =0;i&lt;ps.length; i++)&#123; var p = ps[i]; for(var key in p)&#123; alert(key + &quot;:&quot; + p[key]); &#125;&#125; Json数据和Java对象的相互转换 Json解析器： 常见的解析器：Jsonlib，Gson，fastjson，jackson（springMVC内置） Json转为Java对象 导入Jackson相关jar包 创建Jsckson核心对象 OBjectMapper 调用 ObjectMapper的相关方法进行转换 readValue(Json字符串数据, Class) Java对象转换为Json 使用步骤： 导入Jackson相关jar包 创建Jsckson核心对象 OBjectMapper 调用 ObjectMapper的相关方法进行转换 转换方法： writeValue(参数1，obj): 参数1： ​ File：将obj对象转换为Json字符串，并保存到指定的文件中 ​ Writer：将obj对象转换为Json字符串，并将Json数据填充到字符输出流中 ​ OutputStream：将obj对象转换为Json字符串，并将Json数据填充到字节流输出 流中 writeValueAsString(obj)：将对象转为Json字符串 注解： @JsonIgnore：排除（忽略）属性。 @JsonFormat：属性值的格式化。 复杂Java对象的转换 List Map","tags":["Ajax","Json"],"categories":["前端"]},{"title":"MySQL数据库知识总结（一）-常用操作","path":"/2020/05/08/002.MySQL数据库知识总结（一）/","content":"知识点不常用就会忘记。这篇文章大体写了单表操作的一些常用语法，方便以后查询和回顾复习。 数据库大体概念对应关系： 数据库（DATABASE）：文件夹 表（TABLE）：文件 数据：文件中的数据 行（记录）；列（字段） 四种分类1.DDL：数据定义语言DDL（Data Definition Language）数据定义语言，用来定义数据库对象：数据库、表、列等。关键字：CREATE、DROP、ALTER等。 对数据库：CRUD1.C（Create）：创建 创建数据库： 1CREATE DATABASE 数据库名称； 创建数据库，判断不存在之后再创建： 1CREATE DATABASE IF NOT EXISTS 数据库名称； 创建数据库，并制定字符集： 1CREATE DATABASE IF NOT EXISTS 数据库名称 CHARACTER SET GBK; 2.R（Retrieve）：查询 查询所有数据库的名称： 1SHOW DATABASES; 查询某个数据库的字符集（创建语句）： 1SHOW CREATE DATABASE 数据库名称； 3.U（Update）：修改 修改数据库的字符集 1ALTER DATABASE 数据库名称 CHARACTER SET UTF8； 4.D（Delete）：删除 删除数据库 1DROP DATABASE 数据库名称； 判断数据库是否存在，存在则删除 1DROP DATABASE IF EXISTS 数据库名称； 5.使用数据库 查询当前正在使用的数据库名称 1SELECT DATABASE(); 使用数据库 1USE 数据库名称； 对表：CRUD1.C（Create）：创建 创建表： 123456CREATE TABLE 表名称（ 列名1 数据类型1， 列名2 数据类型2， .... 列名n 数据类型n）；-- 注意：最有一列，不需要加逗号 数据类型： INT ：整数类型 DOUBLE：小数类型，source double（4,1），表示共四位，小数点后取一位 DATE：日期，只包含年月日，yyyy-MM-dd HH:mm:ss DATATIME：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss TIMESTAMP：时间戳类型，包含年月日，不赋值或NULL则使用系统时间 VARCHAR：字符串，name varchar（20）：姓名最大20个字符。 复制现有数据库中的表： 123456CREATE TABLE 表名称（ 列名1 数据类型1，列名2 数据类型2， .... 列名n 数据类型n）；-- 注意：最有一列，不需要加逗号 2.R（Retrieve）：查询 查询某个数据库中的所有表名称： 1SHOW TABLES; 查询表结构： 1DESC 表名； 3.U（Update）：修改 修改表名： 1ALTER TABLE 表名 RENAME TO 新表名； 修改表的字符集： 1ALTER DATABASE 表名 CHARACTER SET UTF8； 添加一列： 1ALTER TABLE 表名 ADD 列名 数据类型； 修改列名称 类型： 12ALTER TABLE 表名 CHANGE 列名 新列名 新数据类;型；ALTER TABLE 表名 MODIFY 列名 新数据类型； 删除列： 1ALTER TABLE 表名 DROP 列名； 4.D（Delete）：删除 删除表 1DROP TABLE 表名； 判断数据库是否存在，存在则删除 1DROP TABLE IF EXISTS 数据库名称； 2.DML：数据操作语言DML（Data Manipulation Language），对数据库中的表的数据进行增删改。关键字：INSERT、DELETE、UPDATE等。 1.添加数据1INESRT INTO 表名(列名1,列名2,...列名n) VALUE(值1,值2,...值n)； 注意： 列名和值要一一对应 如果在表名后不定义列名，则默认给所有列添加值 除了数字类型，其他类型需要使用引号（单双都可） 2.删除数据1DELETE FROM 表名 WHERE 条件； 注意： 如果不加条件，默认删除表中所有记录。 如果要删除所有记录。有两种方式： 12DELETE FEOM 表名;-- 不推荐，有多少记录则删除多少次，效率低TEUNCATE TABLE 表名;-- 推荐使用，效率高，先删除整个表，人后再创建一张一样的空表 3.修改数据1UPDATE 表名 SET 列名1 = 值1, 列名2=值2,... WHERE 条件； 注意： 如果不加任何条件，则会将表中的所有记录全部修改。 3.DQL：数据查询语言DQL（Data Query Language），查询数据库中表的记录（数据）。关键字：SELECT、WHERE等。 1.语法SELECT 字段列表 FROM 表名列表 WHERE条件列表 GROUP BY 分组列表 HAVING 分组之后的条件 ORDER BY 排序 LIMIT 分页限定 2.基础查询 多个字段的查询 12SELECT 列名1,列名2 FROM 表名；SELECT * FEOM 表名；-- 查询所有表名 去除重复 12SELECT DISTINCT 列名 FROM 表名;SELECT DISTINCT 列名1,列名2 FROM 表名; -- 两列数据完全一致才可以去重 计算列 123SELECT 列名1,列名2,列名3,列名2 + 列名3 FROM 表名;-- 如果一列有null值，可以使用IFNULL()判断SELECT 列名1,列名2,列名3,列名2 + IFNULL(列名3,0) FROM 表名; 起别名 12-- 可以使用AS对列起别名SELECT 列名1,列名2,列名3,列名2 + IFNULL(列名3,0) AS 列表3` FROM 表名; 3.条件查询 WHERE子句后跟条件 123456789101112131415-- 查询年龄等于20岁SELECT * FROM 表名 WHERE 列名 = 20;-- 查询年龄不等于20岁SELECT * FROM 表名 WHERE 列名 != 20;-- 或者使用&lt;&gt;-- 查询年龄大于等于20 或小于等于30岁SELECT * FROM 表名 WHERE 列名 BETWEEN 20 AND 30;-- 或者使用 &amp;&amp;(AND) 链接两条语句-- 查询年龄15,20,25岁的信息SELECT * FROM 表名 WHERE 列名 = 15 OR 列名 = 20 OR 列名 = 25;SELECT * FROM 表名 WHERE 列名 IN (15,20,25);-- 查询带有null值的信息SELECT * FROM 表名 WHERE 列名 IS NULL;-- 不是NULL,则使用 IS NOT NULL-- 模糊查询SELECT * FROM 表名 WHERE 列名 LIKE &#x27;飞%&#x27;; -- 可以查到飞机，飞船，飞毛腿等等SELECT * FROM 表名 WHERE 列名 LIKE &#x27;_飞%&#x27;; -- 可以查到‘大飞哥’等第二个字是飞的信息SELECT * FROM 表名 WHERE 列名 LIKE &#x27;%飞%&#x27;; -- 查询包含飞的任意信息 运算符 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;、&lt;&gt;(!&#x3D;) BETWEEN…AND IN(集合) LIKE：模糊查询 占位符： _：单个任意字符 %：多个任意字符 IS NULL：null值判断 AND 或 &amp;&amp; OR 或 || NOT 或 ！ 4.排序查询 语法： 1234SELECT * FROM 表名 ORDER BY 列名 ASC;-- 升序SELECT * FROM 表名 ORDER BY 列名 DESC;-- 降序-- 多条件排序SELECT * FROM 表名 ORDER BY 列名1 ASC, 列名2 DESC;-- 满足第一列条件后按照第二列条件排序 排序方式： ASC-升序；DESC-降序 注意： 有多个排序条件时，则当前面的条件值相同时，才会判断第二条件 5.聚合函数将一列数据作为一个整体，进行纵向的计算。其计算会排除NUll值。 COUNT：计数 12SELECT COUNT(列名) FROM 表名;SELECT COUNT(IFNULL(列名,0) FROM 表名; MAX：最大值 1SELECT MAX(列名) FROM 表名; MIN：最小值 1SELECT MIN(列名) FROM 表名; SUM：求和 1SELECT SUM(列名) FROM 表名; AVG：平均值 1SELECT AVG(列名) FROM 表名; 6.分组查询 语法：GROUP BY 1234567SELECT 分组字段,聚合函数 FROM 表名 GROUP BY 分组字段;-- 举例，按性别分组，展示数学平均分和人数：SELECT sex, AVG(math), COUNT(id) FROM student GROUP BY sex;-- 举例，按性别分组，展示数学平均分和人数 要求：分数不低于70分：SELECT sex, AVG(math), COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;-- 举例，按性别分组，展示数学平均分和人数 要求：分数不低于70分，且分组之后人数要大于2人：SELECT sex, AVG(math), COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; 注意： 分组之后查询的字段：分组字段、聚合函数 WHERE 和 HAVING 的区别： WHERE在分组之前进行限定，如果不满足条件，则不参与分组；HAVING在分组之后进行限定，如果不满足条件则不会呗查询出来。 WHERE之后不可以跟聚合函数，HAVING可以进行聚合函数的判断。 7.分页查询 语法：LIMIT 开始的索引,每页查询的条数； 公式：开始的索引 &#x3D; (当前的页码 - 1) * 每页显示的条数 1234-- 每页显示3条记录SELECT * FROM 表名 LIMIT 0,3; -- 第一页SELECT * FROM 表名 LIMIT 0,3; -- 第二页SELECT * FROM 表名 LIMIT 0,3; -- 第三页 LIMIT是MySQL特有的语法方式。 8.约束 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。 分类： 主键约束：primary key，非空且唯一 一张表只能有一个字段为主键；主键就是表中记录的唯一标识 123456789101112131415-- 创建表示添加主键约束CREATE TABLE 表名( id INT PRIMARY KEY, NAME VARCHAR(20) );-- 创建表后，添加非空约束ALTER TABLE 表名 MODIFY id PRIMARY KEY;-- 删除非空约束ALTER TABLE 表名 DROP PRIMARY KEY;-- 自动增长CREATE TABLE 表名( id INT PRIMARY KEY AUTO_increment,-- 主键且自动增长 NAME VARCHAR(20));ALTER TABLE 表名 MODIFY id INT AUTO_INCREMENT;-- 添加自动增长 非空约束 123456789-- 创建表示添加非空约束CREATE TABLE 表名( id INT, NAME VARCHAR(20) NOT NULL);-- 创建表后，添加非空约束ALTER TABLE 表名 MODIFY NAME VARCHAR(20) NOT NULL;-- 删除非空约束ALTER TABLE 表名 MODIFY NAME VARCHAR(20); 唯一约束 123456789-- 创建表时，添加唯一约束CREATE TABLE 表名（ id INT, phone_number VARCHAR(20) UNIQUE）;-- 删除唯一约束ALTER TABLE 表名 DROP INDEX phone_number; -- 唯一约束又名唯一索引--创建表后，添加唯一约束ALTER TABLE 表名 MODIFY phone_number VARCHAR(20) UNIQUE; 外键约束：foreign key，值可以为NULL 1234567891011-- 创建表示添加外键约束(外键对应主表应先创建，否则会报错)CREATE TABLE 表名( id INT, NAME VARCHAR(20) NOT NULL 外键列, -- 外键对应主表的主键 CONSTRAINT 外键名称 FOREIGN KEY (外键列名称) REFERENCES 主表名称(主表列名));-- 删除外键ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;-- 创建表之后，添加外键ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN (外键列名称) REFERENCES 主表名称(主表列名称) 级联操作 12-- 添加外键时，设置级联更新，级联删除（可以同时写，也可以分开写）ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN (外键列名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE; 分类： 级联更新：ON UPDATE CASCADE 级联删除：ON DELETE CASCADE 4.DCL：数据库控制语言DCL（Data Control Language），定义数据库的访问权限和安全级别，以及创建用户。关键字：GRANT、REVOKE等。","tags":["MySQL"],"categories":["后端"]},{"title":"1.两数之和","path":"/2020/04/20/001.(Algo)两数之和/","content":"167. Two Sum II - Input array is sorted (Easy)题目描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路： 暴力破解 hashmap 代码实现： 暴力破解，采用双循环，从头到尾匹配 注意：这里采用头查法，动画演示如下 IU4Hv8.gif 123456789101112public class _1两数之和 &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[]&#123;j, i&#125;; &#125; &#125; &#125; throw new RuntimeException(&quot;No two sum solution&quot;); &#125;&#125; 复杂度分析： 时间复杂度：O(n^2)。 双循环，每个为O(n)，则O(n^2)。 空间复杂度：O(1) 构造HashMap，进行判断，用空间换时间 123456789101112131415161718192021222324252627282930313233public int[] twoSum(int[] nums, int target) &#123; int n = nums.length; if(nums == null || nums.length == 0)\treturn res; HashMap&lt;Integer, Integer&gt; index = new HashMap&lt;&gt;(); // 构造一个哈希表：元素映射到相应的索引 for (int i = 0; i &lt; n; i++) index.put(nums[i], i); for (int i = 0; i &lt; n; i++) &#123; int other = target - nums[i]; // 如果 other 存在且不是 nums[i] 本身 if (index.containsKey(other) &amp;&amp; index.get(other) != i) return new int[] &#123;i, index.get(other)&#125;; &#125; return new int[] &#123;-1, -1&#125;;&#125;//一个for循环写法，即在构造Hash表时也判断是否存在满足条件的元素public int[] twoSum(int[] nums, int target) &#123; int[] res = new int[2]; if(nums == null || nums.length == 0)\treturn res; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; int temp = target - nums[i]; if(map.containsKey(temp))&#123; res[1] = i; res[0] = map.get(temp); &#125; map.put(nums[i], i); &#125; return res;&#125; 复杂度分析： 时间复杂度：O(1)，哈希表的查询时间为O(1) 空间复杂度：O(n)，哈希表存储需要空间较多 来源： 力扣（LeetCode） GitHub 算法题项目Leetcode 题解 - 目录.md","tags":["Algorithms","双指针"],"categories":["LeetCode"]},{"title":"说明","path":"/2020/04/14/说明/","content":"说明个人博客，分享学习经验、趣闻。 IU47gf.md.jpg 大体计划每月至少写一篇学习笔记，或者其他相关文章。督促自己。"},{"title":"Hello World","path":"/2020/04/14/000.hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"path":"/notes/index.html","content":"写在前面欢迎来到我的笔记小站！ 这个模块是一个记录分享小站，写一些自己的生活片段，记录一段时光碎片。在多年后回看，仍会有一些感触。"},{"path":"/more/index.html","content":"这里还没有装修好 哈"},{"title":"第一篇测试","path":"/notes/琐碎生活/index.html","content":"这里是分类第一篇文章测试"}]